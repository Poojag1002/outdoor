---
title: "Internet CBT DMEC v2 (Pooled)"
---

```{r}
#| label: data_import_scr
#| output: false

library(tidyREDCap)
library(tidyverse)
library(expss)

rm(list = ls()) # Ensures workspace is clear before starting.

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("nurture_u_key"), # API Token.
  record_id = "screening_id", # Tells R the label of the Record ID on REDCap.
  drop_blank = FALSE
)
```

```{r}
library(labelled)
library(UpSetR)
.sets = nurtureu_introduction %>%
  select("screening_id", matches("intro_advert_"))
names(.sets) <- as.character(var_label(.sets)) 
.sets <- remove_var_label(.sets)


.sets <- .sets %>%
  replace(.sets == "Unchecked", 0)
.sets <- .sets %>%
  replace(.sets == "Checked", 1)  

names(.sets) <- sapply(strsplit(names(.sets), split='=', fixed=TRUE), function(x) (x[2]))
names(.sets) <- sapply(strsplit(names(.sets), split=')', fixed=TRUE), function(x) (x[1]))

.sets[ , -1] <- apply(.sets[ , -1,drop=F], 2,           
                              function(x) as.numeric(as.character(x)))
#-------------------------------------------------------------------------------
upset(.sets, nsets = 15, number.angles = 0, point.size = 1.5, line.size = 1, 
      mainbar.y.label = "Promotion Intersections", sets.x.label = "Participants per Promotion", 
      text.scale = c(1.3, 1.3, 1, 1, 0.75, 0.75), mb.ratio = c(0.55, 0.45), order.by = "freq")
#-------------------------------------------------------------------------------
```

```{r}
#| label: consort_data_scr
#| output: false

library(consort)
.N <- nrow(nurtureu_introduction)


.trialno <- nurtureu_introduction$screening_id

.exc1 <- rep(NA, .N)
.exc1 <- ifelse(nurtureu_introduction$intro_ineligible == 1, NA, "Did not meet basic eligibility criteria")

.induc1 <- rep(NA, .N)
.induc1[is.na(.exc1)] <- .trialno[is.na(.exc1)]

.exc2 <- rep(NA, .N)
.exc2[nurture_u_consent_for_screening$nurture_u_consent_for_screening_complete == "Incomplete"] <- "Incomplete" 

.induc2 <- rep(NA, .N)
.induc2[is.na(.exc2)] <- .trialno[is.na(.exc2)]

.exc3 <- rep(NA, .N)
.exc3[grepl("Incomplete", lidas_adapted$lidas_adapted_complete, ignore.case = TRUE)] <- "Incomplete"
.exc3[grepl("Deviat", .trialno, ignore.case = TRUE)] <- "Deviated Participant*"
.exc3[is.na(.exc3)] <- ifelse(consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete[is.na(.exc3)] == "Incomplete", 
         "Eligible but did not consent", .exc3[is.na(.exc3)])
.exc3[!grepl("Incomplete", ineligible$ineligible_complete, ignore.case = TRUE)] <- "Ineligible"
.exc3[grepl("Duplicated", .trialno, ignore.case = TRUE)] <- "Duplicated participant"

.induc3 <- rep(NA, .N)
.induc3[is.na(.exc3)] <- .trialno[is.na(.exc3)]

.arm <- rep(NA, .N)
.arm[!is.na(.induc3) & (consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete == "Complete")] <- "Bounce Back"
.arm[!is.na(.induc3) & (consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete == "Complete")] <- "Internet CBT"
.arm[!is.na(.induc3) & (consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete == "Complete")] <- "Reducing Worry"

.phq9 <- rep(NA, .N)
.phq9[!is.na(.induc3)] <- phq9$phq_9_total[!is.na(.induc3)]

.gad7 <- rep(NA, .N)
.gad7[!is.na(.induc3)] <- gad7$gad_7_total[!is.na(.induc3)]

.lidas <- rep(NA, .N)
.lidas[!is.na(.induc3)] <- lidas_adapted$lidas_meet_past_mde[!is.na(.induc3)]

.pswq <- rep(NA, .N)
.pswq[!is.na(.induc3)] <- shortform_penn_state_worry_questionnaire$pswq_8_total[!is.na(.induc3)]

.brood <- rep(NA, .N)
.brood[!is.na(.induc3)] <- item_brooding_scale$bro_5_total[!is.na(.induc3)]

#.pri_out <- data.frame(.induc3, .arm, .phq9, .gad7, .lidas)

.df_con <- data.frame(.trialno, .exc1, .induc1, .exc2, .induc2, .exc3, .induc3, .arm, .phq9, .gad7, .lidas, .brood, .pswq)

```

```{r}
#| label: data_import_cbt
#| output: false

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("internet_cbt_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NA_1",
  drop_blank = FALSE
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
#.df_list <- list(academic_grades_selfreport, ae, apoi, audit, brief_resilience_scale, brooding_scale2_items, change_in_habit_applied_to_problemsolving, change_in_habit_applied_to_worry_61f68e, childhood_experience_of_care_and_abuse, cidisc, contact_details, demographics, imported_fields, motivation_to_change, negative_experience_measure, perceived_stress_scale, personality_measures, phq2_gad2, physical_health_and_lifestyle_questions, problem_clarification_819b84, problem_description, problemsolving_skills, promiss_applied_cognition_abilities_scale, pssi, randomisation, relationship_questionnaire, risk_contactbaseline, rosenberg_self_esteem, sci_sleep_condition_indicator, selfcompassion_scaleshort_form, selfcontrol, selfefficacymastery, social_support_and_social_competence, stress, substance_abuse, suicidality, therapy_expectation, therapy_preference_and_expectancy, trial_management_crf, ucla_loneliness_scale_4item, use_of_cognitive_and_behavioural_skills, use_of_services_treatment_receivedincorporating_nh, wemwbs, withdrawal, wsas)

```

```{r}
#| label: rand_alloc
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]

```

```{r}
#| label: consort_cbt_data
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_cbt")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()

.exc1_cbt <- rep(NA, .N)
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") > 14] <- "Incomplete (Blocked)"
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") <= 14] <- "Incomplete (awaiting data entry)"

# List of participants who have finished Baseline.
.induc1_cbt <- rep(NA, .N)
.induc1_cbt[is.na(.exc1_cbt)] <- .scr_id$.trialno_cbt[is.na(.exc1_cbt)]
.induc1_cbt <- as.data.frame(.induc1_cbt)

# Identifies which arm each participant has been allocated to.
.arm_cbt <- rep(NA, .N)
.arm_cbt[!is.na(.induc1_cbt)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_cbt[!is.na(.induc1_cbt)] <- ifelse(grepl(.arm_a,.arm_cbt[!is.na(.arm_cbt)]), "Arm A", "Arm B")

# Weekly Data
colnames(.induc1_cbt) <- "record_id"
.wk_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_acu_timepoint == "Between baseline to final follow-up assessment")
.wk_withdraw <- merge(.induc1_cbt, select(.wk_withdraw, "record_id", "with_acu_ch_dt"), by = "record_id", all = TRUE)
.wk_withdraw <- inner_join(.induc1_cbt, .wk_withdraw, by = "record_id", multiple = "any")
.wk_withdraw <- mutate(.wk_withdraw, .wk_comp = NA)

.wk_data <- lapply (1 : 9, function (x)  data.frame(.wk_withdraw))
.wk_dfs <- list(phq2_gad2, stress, use_of_cognitive_and_behavioural_skills, change_in_habit_applied_to_worry_61f68e ,change_in_habit_applied_to_problemsolving,
            selfcompassion_scaleshort_form, brooding_scale2_items, selfefficacymastery, problem_clarification_819b84)

  
for (i in seq(1,8)) {
  for (j in seq(1,length(.wk_dfs))) {
    .temp_data1 <- merge(.wk_data[[i]][1:2], select(filter(as.data.frame(.wk_dfs[j]), grepl(as.character(i), redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.wk_dfs[j])[ncol(as.data.frame(.wk_dfs[j]))])), by = "record_id", all = TRUE)
    .temp_data1 <- inner_join(.wk_data[[i]], .temp_data1, by = "record_id", multiple = "any")
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 2] <- "Incomplete (overdue)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 1] <- "Incomplete (awaiting data entry)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 0] <- "Incomplete (awaiting access)"
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
    .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
    .wk_data[[i]] <- inner_join(.wk_data[[i]], select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
    
  }
  .wk_data[[i]][3][is.na(.wk_data[[i]][ncol(.wk_data[[i]])])] <- .scr_id$.trialno_cbt[is.na(.wk_data[[i]][ncol(.wk_data[[i]])])]
  .wk_data[[i]][is.na(.wk_data[[i]]["record_id"]),] <- NA
}



# Finds participants who have not completed the 8 week follow up.
.exc2_cbt <- merge(.induc1_cbt, filter(problem_clarification_819b84, grepl("8", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "problem_clarification_819b84_complete")
.exc2_cbt <- inner_join(.induc1_cbt, .exc2_cbt, by = "record_id", multiple = "any")
.exc2_cbt[2][.exc2_cbt[2] == "Incomplete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(8,9)) == 2] <- "Incomplete (overdue)"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(8,9)) == 1] <- "Incomplete (awaiting data entry)"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(8,9)) == 0] <- "Incomplete (awaiting access)"
.exc2_cbt[2][.exc2_cbt[2] == "Complete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[1])] <- NA
.exc2_cbt <- .exc2_cbt[2]

colnames(.induc1_cbt) <- ".induc1_cbt"
colnames(.exc2_cbt) <- ".exc2_cbt"

# List of participants who have completed 8 week follow up.
.induc2_cbt <- rep(NA, .N)
.induc2_cbt[is.na(.exc2_cbt)] <- .trialno_cbt[is.na(.exc2_cbt)]
.induc2_cbt <- as.data.frame(.induc2_cbt)
.exc2_cbt[is.na(.induc1_cbt)] <- NA

# Finds participants who have not completed 3 month follow up.
#.exc3_cbt = rep(NA, .N)
colnames(.induc2_cbt) <- "record_id"
.exc3_cbt <- merge(.induc2_cbt, filter(open_text_questions_about_therapy, grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "open_text_questions_about_therapy_complete")
.exc3_cbt <- inner_join(.induc2_cbt, .exc3_cbt, by = "record_id", multiple = "any")
.exc3_cbt[is.na(.exc3_cbt)] <- "Incomplete"
.exc3_cbt[.exc3_cbt == "Complete"] <- NA
.exc3_cbt <- .exc3_cbt[2]
colnames(.induc2_cbt) <- ".induc2_cbt"
colnames(.exc3_cbt) <- ".exc3_cbt"

# List of participants who have completed 3 month follow up.
.induc3_cbt <- rep(NA, .N)
.induc3_cbt[is.na(.exc3_cbt)] <- .scr_id$.trialno_cbt[is.na(.exc3_cbt)]
.induc3_cbt <- as.data.frame(.induc3_cbt)
.exc3_cbt[is.na(.induc2_cbt)] <- NA

# Merges cbt data with screening data for complete timeline.
.df <- data.frame(.scr_id, .exc1_cbt, .induc1_cbt, .arm_cbt, .exc2_cbt, .induc2_cbt, .exc3_cbt, .induc3_cbt)
.df_cbt <- merge(.df_con, .df, by = ".trialno", all.x = TRUE)

# Changes the screening arm as only interested in Internet CBT here.
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & is.na(.df_cbt$.trialno_cbt)] <- "Consented but did not start baseline"
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & !is.na(.df_cbt$.trialno_cbt)] <- NA
.df_cbt$.arm[.df_cbt$.arm == "Bounce Back" | .df_cbt$.arm == "Reducing Worry"] <- "Consented to other NURTURE-U Trial"

```

## Consort Diagram

```{r}
#| label: consort_cbt_pool
#| output: false

# Constructs Consort Diagram for pooled data.
.out_cbt <- consort_plot(data = .df_cbt,
                    orders = c(.trialno = "Population",
                               .exc1    = "Excluded",
                               .induc1 = "Start of Screening",
                               .exc2    = "Excluded",
                               .induc2 = "Consented to Screening",
                               .exc3    = "Excluded",
                               .induc3 = "Participant consented to Trial",
                               .arm     = "Excluded",
                               .trialno_cbt = "Start of Baseline",
                               .exc1_cbt = "Excluded",
                               .arm_cbt = "Randomised Participant",
                               .exc2_cbt = "Excluded",
                               .induc2_cbt = "8 Week Follow Up (after brief mediator measures)",
                               .exc3_cbt = "Excluded",
                               .induc3_cbt = "3 Month Follow Up"
                               ),
                    side_box = c(".exc1", ".exc2", ".exc3", ".arm", ".exc1_cbt", ".exc2_cbt", ".exc3_cbt"),
                    labels = c("1" = "Pre-Screening", "2" = "Screening", 
                               "5" = "Baseline", "6" = "Randomisation", 
                               "7" = "Mediator Assessments", "8" = "Follow up Period"),
                    cex = 0.9)

# Creates plot file.
cat(build_grviz(.out_cbt), file = "consort_cbt_pool.gv")

```

```{dot}
//| label: fig-consort_cbt_pool
//| fig-cap: "CONSORT diagram of NURTURE-U Internet CBT (pooled data)."
//| file: consort_cbt_pool.gv
```

```{r}
#| label: data_import_cbt_clean
#| output: false

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("internet_cbt_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NA_1"
)

dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.

```

```{r}

# Baseline Data

.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.trialno_cbt <- as.data.frame(.trialno_cbt)
colnames(.trialno_cbt) <- "record_id"

.base_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_acu_timepoint == "During Baseline")
.base_withdraw <- merge(.trialno_cbt, select(.base_withdraw, "record_id", "with_acu_ch_dt"), by = "record_id", all = TRUE)
.base_withdraw <- inner_join(.trialno_cbt, .base_withdraw, by = "record_id", multiple = "any")
.base_data <- mutate(.base_withdraw, .base_comp = NA)

.base_dfs <- list(contact_details, demographics, childhood_experience_of_care_and_abuse, wemwbs, perceived_stress_scale, pssi, negative_experience_measure, wsas, brief_resilience_scale, academic_grades_selfreport, use_of_services_treatment_receivedincorporating_nh, physical_health_and_lifestyle_questions, cidisc, suicidality, risk_contactbaseline, audit, substance_abuse, sci_sleep_condition_indicator, ucla_loneliness_scale_4item, social_support_and_social_competence, personality_measures, rosenberg_self_esteem, brief_measure_of_hopelessness, relationship_questionnaire, promiss_applied_cognition_abilities_scale, motivation_to_change, selfcontrol, therapy_preference_and_expectancy, apoi, problem_description, therapy_expectation, problemsolving_skills, randomisation, imported_fields)

for (j in seq(1,length(.base_dfs))) {
  .temp_data1 <- merge(.base_data[1], select(filter(as.data.frame(.base_dfs[j]), grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.base_dfs[j])[ncol(as.data.frame(.base_dfs[j]))])), by = "record_id", all = TRUE)
  .temp_data1 <- inner_join(.base_data, .temp_data1, by = "record_id", multiple = "any")
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") > 14] <- "Incomplete (overdue)"
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") <= 14] <- "Incomplete (awaiting data entry)"
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
  .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
  .base_data <- inner_join(.base_data, select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
}
.base_data[3][is.na(.base_data[ncol(.base_data)])] <- .scr_id$.trialno_cbt[is.na(.base_data[ncol(.base_data)])]
.base_data[is.na(.base_data["record_id"]),] <- NA

```

```{r}
#| label: bline_data_comp
#| output: false
#| 
.target_string <- c("Incomplete (overdue)")

#.M <- as.matrix(.base_data)
#.M[,-(1:3)] <- ifelse(.M[,-(1:3)] == .target_string ,1,0)

is_present <- function(x) {
  x %in% .target_string 
}

.base_data_t <- as.data.frame(t(.base_data))
.base_data_t <- .base_data_t %>% 
  rowwise() %>% 
  mutate(num_over = sum(is_present(across(matches(colnames(.base_data_t))))))

.base_comp <- data.frame(crf = colnames(.base_data)[-(1:3)], num_exp = rep(nrow(.base_data),length(.base_data)-3), num_over = .base_data_t$num_over[-(1:3)])

```

```{r}
#| label: wk_data_comp
#| output: false

.wk_comp <- lapply (1 : 8, function (x)  data.frame())

.target_string <- c("Incomplete (overdue)")

is_present <- function(x) {
  x %in% .target_string 
}

.wk_data_t <- as.data.frame(t(.wk_data[[1]]))
.wk_data_t <- .wk_data_t %>% 
  rowwise() %>% 
  mutate(num_over = sum(is_present(across(matches(colnames(.wk_data_t))))))

.wk_exp_filter <- filter(.wk_data[[1]], !is.na(.wk_data[[1]]$record_id) & (.wk_data[[1]]$problem_clarification_819b84_complete != "Incomplete (awaiting access)" | is.na(.wk_data[[1]]$problem_clarification_819b84_complete)))

.wk_comp[[1]] <- data.frame(crf = colnames(.wk_data[[1]])[-(1:3)], num_exp = rep(nrow(.wk_exp_filter),length(.wk_data[[1]])-3), num_over = .wk_data_t$num_over[-(1:3)])

.wk_comp_total <- .wk_comp[[1]]
#,length(.wk_data)
for (i in seq(2,length(.wk_data)-1)) {
  .wk_data_t <- as.data.frame(t(.wk_data[[i]]))
  .wk_data_t <- .wk_data_t %>% 
    rowwise() %>% 
    mutate(num_over = sum(is_present(across(matches(colnames(.wk_data_t))))))

  .wk_exp_filter <- filter(.wk_data[[i]], !is.na(.wk_data[[i]]$record_id))
  .wk_exp_filter <- filter(.wk_exp_filter, (.wk_exp_filter$problem_clarification_819b84_complete != "Incomplete (awaiting access)" | is.na(.wk_exp_filter$problem_clarification_819b84_complete)))
  
  .wk_comp[[i]] <- data.frame(crf = colnames(.wk_data[[i]])[-(1:3)], num_exp = rep(nrow(.wk_exp_filter),length(.wk_data[[i]])-3), num_over = .wk_data_t$num_over[-(1:3)])
  
  .wk_comp_total[2:3] <- .wk_comp_total[2:3] + .wk_comp[[i]][2:3]
}
#.wk_exp_filt <- filter(.wk_data[[1]], !is.na(.wk_data[[1]]$record_id) & (.wk_data[[1]]$problem_clarification_819b84_complete != "Incomplete (awaiting access)" | is.na(.wk_data[[1]]$problem_clarification_819b84_complete)))
#"Incomplete (awaiting access)"



```

## Recruitment (Actual vs. Expected)

```{r}
#| label: fig-bline_recruit_cbt
#| fig-cap: "Summary of Internet CBT recuitment (Actual vs Expected)."

# The following groups the data by calender month and creates a cumulative count of the data.
.cum_count <- select(dfs$randomisation, c("record_id", "randomisation_complete", "rando_dt")) %>% 
  group_by(month = lubridate::floor_date(rando_dt, 'month')) %>% 
  summarise(count = n()) %>% 
  mutate(cum_count = cumsum(count)) %>% 
  ungroup
.cum_count <- na.omit(.cum_count)

# Creates a new variable used to differentiate between Actual and Expected data - used in ggplot().
.part_count <- .cum_count %>%
  mutate(state = "Actual")

# Creates a dataframe similiar to .part_count for Expected data. Data taken from Revised_actual_cumulative recruitment_v0.1.
.start_date <- as.Date("2023/07/01")
.exp_count <- data.frame(
  month = seq(.start_date, by = "month", length.out = 18),
  count = c(34,34,34,42,42,42,42,42,42,42,42,36,36,42,42,42,42,42)) %>%
  mutate(cum_count = cumsum(count)) %>%
  mutate(state = "Expected")

# Combines the Actual and Expected data.
.part_count_both <- rbind(.part_count, .exp_count)

.lower = 0 # Sets lower limit for primary y axis.
.higher = max(.part_count_both$count) + ceiling(max(.part_count_both$count)/10) # Sets upper limit for primary y axis.
.coeff = max(.part_count_both$cum_count)/.higher # This is used to scale the secondary y axis.

.int_breaks_rounded <- function(x, n = 5)  pretty(x, n)[round(pretty(x, n),1) %% 1 == 0]

#Visualisation.
ggplot(.part_count_both, aes(fill=state, y=cum_count/.coeff, x=month)) + # Selects data for the graph. Note the secondary y axis data is divided by .coeff so that it will fit the modified axis.
  geom_bar(position="dodge", stat="identity", alpha = .5) + # Creates a column graph with both actual and expected cumulative data.
  geom_line(aes(x = month, y = count, color = state), linewidth = 1) + # Creates a line graph with both actual and expected monthly recruitment data.
  geom_point(aes(y=count, colour = state), size=2) + # Adds a point to each month on the line graph (this helps with readability).
  geom_text(
    aes(label = cum_count),
    colour = "black", size = 1.8,
    vjust = -1.1, position = position_dodge(25)
    ) +
  coord_cartesian(
    xlim = NULL,
    ylim = c(.lower, .higher), # Sets the primary y axis limits.
    expand = TRUE,
    default = FALSE,
    clip = "on"
  ) +
  scale_x_date(date_labels = "%m/%Y", name = "Date") + # Sets format for dates on the x axis.
  scale_y_continuous(breaks = .int_breaks_rounded,
    # Features of the first axis
    name = "Monthly Randomisation", # Sets name of primary y axis.
    # Add a second axis and specify its features. Note that it is scaled by .coeff to fit the data modification in ggplot().
    sec.axis = sec_axis(~.*.coeff, name="Cumulative Randomisation", breaks = .int_breaks_rounded)
  ) + 
  theme_minimal() + # Sets theme for the graph.
  labs(fill = NULL, color = NULL) + # Controls settings for the legend.
  theme(
    legend.position="top", # Sets the position of the graph legend.
    axis.title.x = element_text(size = 12), # Controls settings for the x axis.
    axis.title.y = element_text(size=13), # Controls settings for the primary y axis.
    axis.title.y.right = element_text(size=13, angle = 90) # Controls settings for the secondary y axis.
  ) +
  ggtitle("Monthly Randomisation Count\nin Internet CBT") # Creates title for the graph.

```

```{r}
#| label: tbl-bline_sites_cbt
#| tbl-cap: "Summary of Internet CBT sites open."

# The following creates a count of how many participants were recruited each month by site.
.cum_count <- na.omit(merge(select(dfs$randomisation, c("record_id", "rando_dt")),
                    select(dfs$contact_details, c("record_id", "cont_uni")), by = "record_id")) %>%
  group_by(month = lubridate::floor_date(rando_dt, 'month'), cont_uni) %>%
  summarise(count = n())

# The following take a cumulative count of sites that recruited their first participant by month.
.cum_count <- .cum_count[!duplicated(.cum_count$cont_uni), ] %>%
  group_by(month) %>%
  summarise(count = n()) %>%
  mutate(cum_count = cumsum(count)) %>% 
  ungroup

# Visualisation.
knitr::kable((select(.cum_count, c("month", "cum_count"))), col.names = c("Month", "Number of sites open") )

```

## Numbers of and reasons for ineligibility, non-approach and potential participant refusals

## Participant Demographics

```{r}
#| label: pri_out_pri_pool

.pri_out <- filter(.df_cbt, !is.na(.df_cbt$.trialno_cbt))

.phq_out_table <- data.frame(time = c("PHQ-9 (Baseline)", "PHQ-9 (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "Incomplete (Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.gad_out_table <- data.frame(time = c("GAD-7 (Baseline)", "GAD-7 (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "Incomplete (Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.lidas_out_table <- data.frame(time = c("LIDAS (Baseline)", "LIDAS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "Incomplete (Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.pri_out_table <- rbind(.phq_out_table,.gad_out_table)

```

```{r}
#| label: demo_data
#| output: false

.lid_count <- group_by(.pri_out, .lidas == 1) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.gad_count <- group_by(.pri_out, .gad7 > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.phq_count <- group_by(.pri_out, .phq9 > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.phq_count[.phq_count[1] == TRUE,][1] <- colnames(.phq_count)[1]
.gad_count[.gad_count[1] == TRUE,][1] <- colnames(.gad_count)[1]
.lid_count[.lid_count[1] == TRUE,][1] <- colnames(.lid_count)[1]

colnames(.phq_count)[1] <- "characteristic"
colnames(.gad_count)[1] <- "characteristic"
colnames(.lid_count)[1] <- "characteristic"

.demo_table <- rbind(.phq_count[.phq_count[1] != FALSE,], .gad_count[.gad_count[1] != FALSE,], .lid_count[.lid_count[1] != FALSE,])
rownames(.demo_table) = NULL

.gender <- make_choose_one_table(demographics$dem_gender)

.sex_orient <- make_choose_one_table(demographics$dem_sex_orient)

.uni_stat <- make_choose_one_table(demographics$dem_uni_status) 

.uni_choice <- make_choose_one_table(contact_details$cont_uni) 

.ethnic <- make_choose_all_table(demographics, "dem_ethnicity")

.disability <- demographics$dem_disability_txt
.disability[is.na(.disability)] <- demographics$dem_disability[is.na(.disability)]
.disability[.disability == "No"] <- "No disability"
.disability <- make_choose_one_table(.disability) 

.diagnosis <- make_choose_all_table(demographics, "dem_diagnos___")

.dem_list <- list(.gender, .sex_orient, .uni_stat, .uni_choice, .ethnic, .disability, .diagnosis)

.col_name <- c("Response","No. of Responses","Percent (%)", "Percent not including NAs (%)")

.dem_list <- lapply (.dem_list, function(x) { colnames(x)[1:length(x)] <- .col_name[1:length(x)];x})
names(.dem_list) <- c(".gender", ".sex_orient", ".uni_stat", ".uni_choice", ".ethnic", ".disability", ".diagnosis")

```

```{r}
#| label: tbl-demo_pri
#| tbl-cap: "Summary of participants with specific criteria."

knitr::kable(.demo_table, col.names = c("Score","No. of Responses","Percent (%)"), align = 'lrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_gender
#| tbl-cap: "Summary of participants gender."

knitr::kable(.dem_list[".gender"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_sex
#| tbl-cap: "Summary of participants sexual orientation."

knitr::kable(.dem_list[".sex_orient"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_uni_choice
#| tbl-cap: "Summary of participants University of study."

knitr::kable(.dem_list[".uni_choice"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_uni_stat
#| tbl-cap: "Summary of participants University status."

knitr::kable(.dem_list[".uni_stat"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_ethnic
#| tbl-cap: "Summary of participants Ethnicity."

knitr::kable(.dem_list[".ethnic"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_disability
#| tbl-cap: "Summary of participants disability status."

knitr::kable(.dem_list[".disability"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'") %>%
  kableExtra::column_spec(1, width = "10cm")

```

```{r}
#| label: tbl-demo_diagnosis
#| tbl-cap: "Summary of participants disability status (continued)."

knitr::kable(.dem_list[".diagnosis"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'") %>%
  kableExtra::column_spec(1, width = "10cm")

```

## Data completeness

### Number of overdue CRFs by CRF

```{r}

knitr::kable(.base_comp, col.names = c("CRF Name", "Number Expected", "Number Overdue"), align = "lrr")

```

```{r}

knitr::kable(.wk_comp_total, col.names = c("CRF Name", "Number Expected", "Number Overdue"), align = "lrr")

```

### Primary Outcome Characteristics

```{r}
#| label: tbl-pri_out_pri_pool
#| tbl-cap: "Summary of Internet CBT Primary Outcome Characteristics."

knitr::kable(.pri_out_table)

```

### Secondary Outcome Characteristics

```{r}
#| label: pri_out_sec_pool

.brood_out_table <- data.frame(time = c("Brood (Baseline)", "Brood (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "Incomplete (Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.pswq_out_table <- data.frame(time = c("PSWQ (Baseline)", "PSWQ (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "Incomplete (Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.sec_imp_out_table <- rbind(.brood_out_table,.pswq_out_table)

.wemwbs_base <- wemwbs %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(wemwbs_complete == "Incomplete") %>%
  select(record_id, wemwbs_complete)

.wsas_base <- wsas %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(wsas_complete == "Incomplete") %>%
  select(record_id, wsas_complete)

.use_base <- use_of_services_treatment_receivedincorporating_nh %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(use_of_services_treatment_receivedincorporating_nh_complete == "Incomplete") %>%
  select(record_id, use_of_services_treatment_receivedincorporating_nh_complete)

.res_base <- brief_resilience_scale %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(brief_resilience_scale_complete == "Incomplete") %>%
  select(record_id, brief_resilience_scale_complete)

.stress_base <- perceived_stress_scale %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(perceived_stress_scale_complete == "Incomplete") %>%
  select(record_id, perceived_stress_scale_complete)

.acad_base <- academic_grades_selfreport %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(academic_grades_selfreport_complete == "Incomplete") %>%
  select(record_id, academic_grades_selfreport_complete)

colnames(.pri_out)[14] <- "record_id"

.pri_out <- merge(.pri_out, .wemwbs_base, by = "record_id", all = TRUE) %>%
  merge(.wsas_base, by = "record_id", all = TRUE) %>%
  merge(.use_base, by = "record_id", all = TRUE) %>%
  merge(.res_base, by = "record_id", all = TRUE) %>%
  merge(.stress_base, by = "record_id", all = TRUE) %>%
  merge(.acad_base, by = "record_id", all = TRUE)

.wemwbs_no <- .pri_out %>%
  filter(wemwbs_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.wsas_no <- .pri_out %>%
  filter(wsas_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.use_no <- .pri_out %>%
  filter(use_of_services_treatment_receivedincorporating_nh_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.res_no <- .pri_out %>%
  filter(brief_resilience_scale_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.stress_no <- .pri_out %>%
  filter(perceived_stress_scale_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.acad_no <- .pri_out %>%
  filter(academic_grades_selfreport_complete == "Incomplete") %>%
  filter(.exc1_cbt == "Incomplete (Blocked)") %>%
  nrow()

.wemwbs_out_table <- data.frame(time = c("WEMWBS (Baseline)", "WEMWBS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.wemwbs_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.wsas_out_table <- data.frame(time = c("WSAS (Baseline)", "WSAS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.wsas_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.use_out_table <- data.frame(time = c("Use of Services (Baseline)", "Use of Services (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.use_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.res_out_table <- data.frame(time = c("Resiliance (Baseline)", "Resiliance (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.res_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.stress_out_table <- data.frame(time = c("Stress (Baseline)", "Stress (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.stress_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )
.acad_out_table <- data.frame(time = c("Academic Outcomes (Baseline)", "Academic Outcomes (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc3_cbt)))),
                             num_over = c(.acad_no, nrow(filter(.pri_out, .pri_out$.exc3_cbt == "Incomplete (overdue)")))
                             )

.sec_out_table <- rbind(.sec_imp_out_table, .wemwbs_out_table, .wsas_out_table, .use_out_table, .res_out_table, .stress_out_table, .acad_out_table)


```

```{r}
#| label: tbl-pri_out_sec_pool
#| tbl-cap: "Summary of Internet CBT Secondary Outcome Characteristics."

knitr::kable(.sec_out_table, col.names = c("Outcome (timepoint)", "Number expected", "Number overdue"))
# outcome (timepoint), number expected, number overdue
```

## Follow Up

### Withdrawals

```{r}
#| label: with_checker

# Prints the number of withdrawals.
.any_with <- ifelse(exists('withdrawal') == TRUE, sprintf("There have been %s withdrawals during this trial", nrow(filter(withdrawal, withdrawal_complete == "Complete"))), "There have been no withdrawals in this trial")
print(.any_with)

```

```{r}
#| label: tbl-withdrawal
#| tbl-cap: "Summary of Reducing Worry withdrawals."

.with_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('withdrawal') == TRUE){.with_list <- select(filter(withdrawal, withdrawal_complete == "Complete"), "with_acu_ch_dt", "with_acu_type", "with_acu_timepoint", "with_acu_reason", "record_id")}
colnames(.with_list) <- c("Date of Status Change", "Withdrawal type", "Withdrawal timepoint", "Reason for withdrawal", "Record ID")

knitr::kable(.with_list)

```

## Safety

### AEs

```{r}
#| label: ae_checker

# Prints the number of AEs.
.any_ae <- ifelse(exists('ae') == TRUE, sprintf("There have been %s AEs during this trial", nrow(filter(ae, ae_complete == "Complete"))), "There have been no AEs in this trial")
print(.any_ae)

```

```{r}
#| label: tbl-ae
#| tbl-cap: "Summary of Adverse Events."

.ae_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('ae') == TRUE){.ae_list <- select(filter(ae, ae_complete == "Complete"), "ae_acu_number", "ae_acu_event_name", "ae_acu_start_dt", "ae_acu_relation" , "ae_acu_ppt_id")}
colnames(.ae_list) <- c("AE Number", "AE Event Name", "AE Start Date", "Relationship to Trial" , "Record ID")

knitr::kable(.ae_list)

```

### SAEs

```{r}
#| label: sae_checker

# Prints the number of SAEs.
.any_sae <- ifelse(exists('sae') == TRUE, sprintf("There have been %s SAEs during this trial", nrow(filter(sae, sae_complete == "Complete"))), "There have been no SAEs in this trial")
print(.any_sae)

```

```{r}
#| label: tbl-sae
#| tbl-cap: "Summary of Severe Adverse Events."

.sae_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('sae') == TRUE){.sae_list <- select(filter(sae, sae_complete == "Complete"), "sae_acu_number", "sae_acu_event_name", "sae_acu_start_dt", "sae_acu_relation" , "sae_acu_ppt_id")}
colnames(.sae_list) <- c("SAE Number", "SAE Event Name", "SAE Start Date", "Relationship to Trial" , "Record ID")

knitr::kable(.sae_list)

```
