---
title: "Outdoor TSC Reports"
date-modified: today
format: html
embed-resources: true
execute:
  echo: false
  warning: false
editor: visual
tbl-cap-location: top
toc: true
toc-depth: 3
toc-title: "Reports:"
title-block-banner: true
---

## Screening

```{r}
#| label: data_import_scr
#| output: false

library(tidyREDCap)
library(tidyverse)
library(expss)

rm(list = ls()) 
token <- "D53E4D05D75354D5E9E324999672561A"
url <- "https://rc.ctu.exeter.ac.uk/api/"
formData <- list("token"=token,
    content='report',
    format='json',
    report_id='209',
    csvDelimiter='',
    rawOrLabel='raw',
    rawOrLabelHeaders='raw',
    exportCheckboxLabel='false',
    returnFormat='json'
)
response <- httr::POST(url, body = formData, encode = "form")
result <- httr::content(response)
print(result)


tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("D53E4D05D75354D5E9E324999672561A"), # API Token.
  record_id = "screening_id", # Tells R the label of the Record ID on REDCap.
  drop_blank = FALSE
)

```

```{r}
#| label: consort_data_scr
#| output: false

library(consort)
.N <- nrow(outdoor_introduction)


.trialno <- outdoor_introduction$screening_id

.exc1 <- rep(NA, .N)
.exc1 <- ifelse(outdoor_introduction$scr_calc == 1, NA, "Did not meet basic eligibility criteria")

.induc1 <- rep(NA, .N)
.induc1[is.na(.exc1)] <- .trialno[is.na(.exc1)]

.exc2 <- rep(NA, .N)
.exc2[nurture_u_consent_for_screening$nurture_u_consent_for_screening_complete == "Incomplete"] <- "Did not complete consent form" 

.induc2 <- rep(NA, .N)
.induc2[is.na(.exc2)] <- .trialno[is.na(.exc2)]

.exc3 <- rep(NA, .N)
.exc3[grepl("Incomplete", lidas_adapted$lidas_adapted_complete, ignore.case = TRUE)] <- "Did not complete screening forms"
.exc3[grepl("Deviat", .trialno, ignore.case = TRUE)] <- "Deviated Participant*"
.exc3[is.na(.exc3)] <- ifelse(consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete[is.na(.exc3)] == "Incomplete", 
         "Eligible but did not consent", .exc3[is.na(.exc3)])
.exc3[!grepl("Incomplete", ineligible$ineligible_complete, ignore.case = TRUE)] <- "Did not meet detailed eligibility criteria***"
.exc3[grepl("Duplicated", .trialno, ignore.case = TRUE)] <- "Duplicated participant**"

.induc3 <- rep(NA, .N)
.induc3[is.na(.exc3)] <- .trialno[is.na(.exc3)]

.arm <- rep(NA, .N)
.arm[!is.na(.induc3) & (consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete == "Complete")] <- "Bounce Back"
.arm[!is.na(.induc3) & (consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete == "Complete")] <- "Internet CBT"
.arm[!is.na(.induc3) & (consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete == "Complete")] <- "Reducing Worry"

.phq9 <- rep(NA, .N)
.phq9[!is.na(.induc3)] <- phq9$phq_9_total[!is.na(.induc3)]

.gad7 <- rep(NA, .N)
.gad7[!is.na(.induc3)] <- gad7$gad_7_total[!is.na(.induc3)]

.lidas <- rep(NA, .N)
.lidas[!is.na(.induc3)] <- lidas_adapted$lidas_meet_past_mde[!is.na(.induc3)]

.pswq <- rep(NA, .N)
.pswq[!is.na(.induc3)] <- shortform_penn_state_worry_questionnaire$pswq_8_total[!is.na(.induc3)]

.brood <- rep(NA, .N)
.brood[!is.na(.induc3)] <- item_brooding_scale$bro_5_total[!is.na(.induc3)]

#.pri_out <- data.frame(.induc3, .arm, .phq9, .gad7, .lidas)
.arm2 <- .arm
.df_con <- data.frame(.trialno, .exc1, .induc1, .exc2, .induc2, .exc3, .induc3, .arm, .arm2)

```

```{r}
#| label: consort_scr
#| output: false

# Constructs Consort Diagram for pooled data.
.out_scr <- consort_plot(data = .df_con,
                    orders = c(.trialno = "Participants accessed REDCap Survey",
                               .exc1    = "Incomplete Screening Status",
                               .induc1 = "Pre-screening",
                               .exc2    = "Incomplete Screening Status",
                               .induc2 = "Consented to Screening",
                               .exc3    = "Incomplete Screening Status",
                               .arm = "Consented to participate",
                               .induc3 = "Participant given access to trial baseline survey"
                               ),
                    side_box = c(".exc1", ".exc2", ".exc3"),
                    allocation = ".arm",
                    labels = c("1" = "Pre-Screening Eligibility Form",
                               "2" = "Pre-Screening",
                               "3" = "Screening", 
                               "5" = "Allocated to trial",
                               "6" = "Given access to trial"),
                    cex = 0.9)

# Creates plot file.
cat(build_grviz(.out_scr), file = "consort_scr.gv")

```

```{dot}
//| label: fig-consort_scr
//| fig-cap: "CONSORT diagram of NURTURE-U Screening Data (pooled data)."
//| file: consort_scr.gv
```

## Bounce Back

```{r}
#| label: data_import_bb_1
#| output: false

rm(list = ls()) # Ensures workspace is empty before importing data.

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("bounce_back_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NB_1 (Duplicate)"
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
#.df_list <- list(academic_grades_selfreport,brief_resilience_scale,contact_details,
#                 demographics, gad7_fu, imported_fields, phq9_fu, randomisation,
#                 risk_contact_fu, trial_management_crf, 
#                 use_of_services_treatment_receivedincorporating_nh, wemwbs,
#                 withdrawal, wsas)

.dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.
names(.dfs) <- set_names(ls(all.names = FALSE))

```

```{r}
#| label: data_filter
#| output: false

# The following filters out duplicate entries from the CRF data.
.df_list <- .dfs %>% 
  lapply(function(x) filter(x,!grepl("Duplicate", record_id, ignore.case = TRUE)))
names(.df_list) <- set_names(ls(all.names = FALSE))
list2env(.df_list, envir = .GlobalEnv)

```

```{r}
#| label: rand_filter
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]
```

```{r}
#| label: Consort_bb_data
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_bb <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_bb")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()

.exc1_bb <- rep(NA, .N)
.exc1_bb[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") > 14] <- "Incomplete form (Blocked)"
.exc1_bb[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") <= 14] <- "Incomplete form (within timepoint window)"

# List of participants who have finished Baseline.
.induc1_bb <- rep(NA, .N)
.induc1_bb[is.na(.exc1_bb)] <- .scr_id$.trialno_bb[is.na(.exc1_bb)]
.induc1_bb <- as.data.frame(.induc1_bb)

# Identifies which arm each participant has been allocated to.
.arm_bb <- rep(NA, .N)
.arm_bb[!is.na(.induc1_bb)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_bb[!is.na(.induc1_bb)] <- ifelse(grepl(.arm_b,.arm_bb[!is.na(.arm_bb)]), "Arm B", "Arm A")

# Finds participants who have not completed the 6 week follow up.
colnames(.induc1_bb) <- "record_id"
.exc2_bb <- merge(.induc1_bb, filter(use_of_services_treatment_receivedincorporating_nh, grepl("6", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_receivedincorporating_nh_complete")
.exc2_bb <- inner_join(.induc1_bb, .exc2_bb, by = "record_id", multiple = "any")
.exc2_bb[2][.exc2_bb[2] == "Incomplete"] <- NA
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 2] <- "Incomplete form (over timepoint window and blocked)"
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 1] <- "Incomplete form (within timepoint window)"
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 0] <- "Incomplete form (has not reached timepoint)"
.exc2_bb[2][.exc2_bb[2] == "Complete"] <- NA
.exc2_bb[2][is.na(.exc2_bb[1])] <- NA
.exc2_bb <- .exc2_bb[2]

colnames(.induc1_bb) <- ".induc1_bb"
colnames(.exc2_bb) <- ".exc2_bb"

# List of participants who have completed 6 week follow up.
.induc2_bb <- rep(NA, .N)
.induc2_bb[is.na(.exc2_bb)] <- .trialno_bb[is.na(.exc2_bb)]
.induc2_bb <- as.data.frame(.induc2_bb)
.exc2_bb[is.na(.induc1_bb)] <- NA

colnames(.induc2_bb) <- "record_id"
.exc3_bb <- merge(.induc2_bb, filter(use_of_services_treatment_receivedincorporating_nh, grepl("12", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_receivedincorporating_nh_complete")
.exc3_bb <- inner_join(.induc2_bb, .exc3_bb, by = "record_id", multiple = "any")
.exc3_bb[2][.exc3_bb[2] == "Incomplete"] <- NA
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 2] <- "Incomplete form (over timepoint window and blocked)"
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 1] <- "Incomplete form (within timepoint window)"
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 0] <- "Incomplete form (has not reached timepoint)"
.exc3_bb[2][.exc3_bb[2] == "Complete"] <- NA
.exc3_bb[2][is.na(.exc3_bb[1])] <- NA
.exc3_bb <- .exc3_bb[2]

colnames(.induc2_bb) <- ".induc2_bb"
colnames(.exc3_bb) <- ".exc3_bb"

# List of participants who have completed 12 week follow up.
.induc3_bb <- rep(NA, .N)
.induc3_bb[is.na(.exc3_bb)] <- .scr_id$.trialno_bb[is.na(.exc3_bb)]
.induc3_bb <- as.data.frame(.induc3_bb)
.exc3_bb[is.na(.induc2_bb)] <- NA

.df <- data.frame(.scr_id, .exc1_bb, .induc1_bb, .arm_bb, .exc2_bb, .induc2_bb, .exc3_bb, .induc3_bb)
.df_bb <- merge(.df_con, .df, by = ".trialno", all = TRUE)
.df_bb$.arm[.df_bb$.arm == "Bounce Back" & is.na(.df_bb$.trialno_bb)] <- "Consented but did not start baseline"
.df_bb$.arm[.df_bb$.arm == "Bounce Back"] <- NA
.df_bb$.arm[.df_bb$.arm == "Internet CBT" | .df_bb$.arm == "Reducing Worry"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: Consort_bb_pooled
#| output: false

.out_bb_pool <- consort_plot(data = .df_bb,
                    orders = c(.induc3 = "Consented to participate",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_bb = "Started Baseline",
                               .exc1_bb = "Incomplete Baseline Status",
                               .arm_bb = "Patient randomised",
                               .exc2_bb = "Lost to Follow Up",
                               .induc2_bb = "6 Week Follow Up",
                               .exc3_bb = "Lost to Follow Up",
                               .induc3_bb = "12 Week Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_bb", ".exc2_bb", ".exc3_bb"),
                    labels = c("1" = "Given access to Bounce Back", "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

cat(build_grviz(.out_bb_pool), file = "consort_bb_pool.gv")

```

```{dot}
//| label: fig-consort_bb_pool
//| fig-cap: "CONSORT diagram of NURTURE-U Bounce Back."
//| file: consort_bb_pool.gv
```

## Internet CBT

```{r}
#| label: data_import_cbt
#| output: false

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("internet_cbt_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NA_1",
  drop_blank = FALSE
)

# The Following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
#.df_list <- list(academic_grades_selfreport, ae, apoi, audit, brief_resilience_scale, brooding_scale2_items, change_in_habit_applied_to_problemsolving, change_in_habit_applied_to_worry_61f68e, childhood_experience_of_care_and_abuse, cidisc, contact_details, demographics, imported_fields, motivation_to_change, negative_experience_measure, perceived_stress_scale, personality_measures, phq2_gad2, physical_health_and_lifestyle_questions, problem_clarification_819b84, problem_description, problemsolving_skills, promiss_applied_cognition_abilities_scale, pssi, randomisation, relationship_questionnaire, risk_contactbaseline, rosenberg_self_esteem, sci_sleep_condition_indicator, selfcompassion_scaleshort_form, selfcontrol, selfefficacymastery, social_support_and_social_competence, stress, substance_abuse, suicidality, therapy_expectation, therapy_preference_and_expectancy, trial_management_crf, ucla_loneliness_scale_4item, use_of_cognitive_and_behavioural_skills, use_of_services_treatment_receivedincorporating_nh, wemwbs, withdrawal, wsas)

```

```{r}
#| label: rand_alloc
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]

```

```{r}
#| label: consort_cbt_data
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_cbt")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()

.exc1_cbt <- rep(NA, .N)
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") > 14] <- "Incomplete form (Blocked)"
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") <= 14] <- "Incomplete form (within timepoint window)"

# List of participants who have finished Baseline.
.induc1_cbt <- rep(NA, .N)
.induc1_cbt[is.na(.exc1_cbt)] <- .scr_id$.trialno_cbt[is.na(.exc1_cbt)]
.induc1_cbt <- as.data.frame(.induc1_cbt)

# Identifies which arm each participant has been allocated to.
.arm_cbt <- rep(NA, .N)
.arm_cbt[!is.na(.induc1_cbt)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_cbt[!is.na(.induc1_cbt)] <- ifelse(grepl(.arm_a,.arm_cbt[!is.na(.arm_cbt)]), "Arm A", "Arm B")

# Weekly Data
colnames(.induc1_cbt) <- "record_id"
.wk_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_acu_timepoint == "Between baseline to final follow-up assessment")
.wk_withdraw <- merge(.induc1_cbt, select(.wk_withdraw, "record_id", "with_acu_ch_dt"), by = "record_id", all = TRUE)
.wk_withdraw <- inner_join(.induc1_cbt, .wk_withdraw, by = "record_id", multiple = "any")
.wk_withdraw <- mutate(.wk_withdraw, .wk_comp = NA)

.wk_data <- lapply (1 : 9, function (x)  data.frame(.wk_withdraw))
.wk_dfs <- list(phq2_gad2, stress, use_of_cognitive_and_behavioural_skills, change_in_habit_applied_to_worry_61f68e ,change_in_habit_applied_to_problemsolving,
            selfcompassion_scaleshort_form, brooding_scale2_items, selfefficacymastery, problem_clarification_819b84)

  
for (i in seq(1,8)) {
  for (j in seq(1,length(.wk_dfs))) {
    .temp_data1 <- merge(.wk_data[[i]][1:2], select(filter(as.data.frame(.wk_dfs[j]), grepl(as.character(i), redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.wk_dfs[j])[ncol(as.data.frame(.wk_dfs[j]))])), by = "record_id", all = TRUE)
    .temp_data1 <- inner_join(.wk_data[[i]], .temp_data1, by = "record_id", multiple = "any")
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 2] <- "Incomplete form (over timepoint window and blocked)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 1] <- "Incomplete form (within timepoint window)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 0] <- "Incomplete form (has not reached timepoint)"
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
    .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
    .wk_data[[i]] <- inner_join(.wk_data[[i]], select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
    
  }
  .wk_data[[i]][3][is.na(.wk_data[[i]][ncol(.wk_data[[i]])])] <- .scr_id$.trialno_cbt[is.na(.wk_data[[i]][ncol(.wk_data[[i]])])]
  .wk_data[[i]][is.na(.wk_data[[i]]["record_id"]),] <- NA
}

.wk_data_all <- .wk_data

# Finds participants who have not completed the 8 week follow up.
#.exc2_cbt <- merge(.induc1_cbt, filter(problem_clarification_819b84, grepl("8", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
#  select("record_id", "problem_clarification_819b84_complete")
#.exc2_cbt <- inner_join(.induc1_cbt, .exc2_cbt, by = "record_id", multiple = "any")
#.exc2_cbt[2][.exc2_cbt[2] == "Incomplete"] <- NA
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 2] <- "Incomplete form (over timepoint window and blocked)"
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 1] <- "Incomplete form (within timepoint window)"
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 0] <- "Incomplete form (has not reached timepoint)"
#.exc2_cbt[2][.exc2_cbt[2] == "Complete"] <- NA
#.exc2_cbt[2][is.na(.exc2_cbt[1])] <- NA
#.exc2_cbt <- .exc2_cbt[2]

#colnames(.induc1_cbt) <- ".induc1_cbt"
#colnames(.exc2_cbt) <- ".exc2_cbt"

# List of participants who have completed 8 week follow up.


# Finds participants who have not completed 3 month follow up.
#.exc3_cbt = rep(NA, .N)
colnames(.induc1_cbt) <- "record_id"
.exc2_cbt <- merge(.induc1_cbt, filter(open_text_questions_about_therapy, grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "open_text_questions_about_therapy_complete")
.exc2_cbt <- inner_join(.induc1_cbt, .exc2_cbt, by = "record_id", multiple = "any")
.exc2_cbt[2][.exc2_cbt[2] == "Incomplete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 2] <- "Incomplete form (over timepoint window and blocked)"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 1] <- "Incomplete form (within timepoint window)"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 0] <- "Incomplete form (has not reached timepoint)"
.exc2_cbt[2][.exc2_cbt[2] == "Complete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[1])] <- NA
.exc2_cbt <- .exc2_cbt[2]

colnames(.induc1_cbt) <- ".induc1_cbt"
colnames(.exc2_cbt) <- ".exc2_cbt"

# List of participants who have completed 3 month follow up.
.induc2_cbt <- rep(NA, .N)
.induc2_cbt[is.na(.exc2_cbt)] <- .trialno_cbt[is.na(.exc2_cbt)]
.induc2_cbt <- as.data.frame(.induc2_cbt)
.exc2_cbt[is.na(.induc1_cbt)] <- NA
.induc2_cbt[is.na(.induc1_cbt)] <- NA

# Merges cbt data with screening data for complete timeline.
.df <- data.frame(.scr_id, .exc1_cbt, .induc1_cbt, .arm_cbt, .exc2_cbt, .induc2_cbt)
.df_cbt <- merge(.df_con, .df, by = ".trialno", all.x = TRUE)

# Changes the screening arm as only interested in Internet CBT here.
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & is.na(.df_cbt$.trialno_cbt)] <- "Consented but did not start baseline"
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & !is.na(.df_cbt$.trialno_cbt)] <- NA
.df_cbt$.arm[.df_cbt$.arm == "Bounce Back" | .df_cbt$.arm == "Reducing Worry"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: consort_cbt_pool
#| output: false

# Constructs Consort Diagram for pooled data.
.out_cbt <- consort_plot(data = .df_cbt,
                    orders = c(.induc3 = "Consented to participate",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_cbt = "Started Baseline",
                               .exc1_cbt = "Incomplete Baseline Status",
                               .arm_cbt = "Participant Randomised",
                               .exc2_cbt = "Lost to Follow Up",
                               .induc2_cbt = "3 Month Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_cbt", ".exc2_cbt"),
                    labels = c("1" = "Given access to Internet CBT",
                               "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

# Creates plot file.
cat(build_grviz(.out_cbt), file = "consort_cbt_pool.gv")

```

```{dot}
//| label: fig-consort_cbt_pool
//| fig-cap: "CONSORT diagram of NURTURE-U Internet CBT (pooled data)."
//| file: consort_cbt_pool.gv
```

## Reducing Worry

```{r}
#| label: data_import_wor_1
#| output: false

library(tidyREDCap)
library(tidyverse)
library(expss)

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("reduce_worry_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NR_1",
  drop_blank = FALSE
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
.dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.
names(.dfs) <- set_names(ls(all.names = FALSE))

#.df_list <- list(academic_grades_selfreport, brief_resilience_scale, brooding_scale2_items, change_in_habit_applied_to_problemsolving, change_in_habit_applied_to_worry_61f68e, contact_details, demographics, imported_fields, negative_experience_measure, perceived_stress_scale, phq2_gad2, problem_clarification_819b84, pssi, randomisation, selfcompassion_scaleshort_form, selfefficacymastery, stress, trial_management_crf, use_of_cognitive_and_behavioural_skills, use_of_services_treatment_received_nhs, wemwbs, withdrawal, wsas)

```

```{r}
#| label: rand_alloc_wor
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]

```

```{r}
#| label: consort_data_wor
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_wor <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_wor")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()


.exc1_wor <- rep(NA, .N)
.exc1_wor[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") > 14] <- "Incomplete form (blocked)"
.exc1_wor[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") <= 14] <- "Incomplete form (within timepoint window)"

# List of participants who have finished Baseline.
.induc1_wor <- rep(NA, .N)
.induc1_wor[is.na(.exc1_wor)] <- .scr_id$.trialno_wor[is.na(.exc1_wor)]
.induc1_wor <- as.data.frame(.induc1_wor)

# Identifies which arm each participant has been allocated to.
.arm_wor <- rep(NA, .N)
.arm_wor[!is.na(.induc1_wor)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_wor[!is.na(.induc1_wor)] <- ifelse(grepl(.arm_a,.arm_wor[!is.na(.arm_wor)]), "Arm A", "Arm B")

# Weekly Data
colnames(.induc1_wor) <- "record_id"
.wk_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_rum_timepoint == "Between baseline to next follow-up assessment")
.wk_withdraw <- merge(.induc1_wor, select(.wk_withdraw, "record_id", "with_rum_ch_dt"), by = "record_id", all = TRUE)
.wk_withdraw <- inner_join(.induc1_wor, .wk_withdraw, by = "record_id", multiple = "any")
.wk_withdraw <- mutate(.wk_withdraw, .wk_comp = NA)

.wk_data <- lapply (1 : 9, function (x)  data.frame(.wk_withdraw))
.wk_dfs <- list(phq2_gad2, stress, use_of_cognitive_and_behavioural_skills, change_in_habit_applied_to_worry_61f68e ,change_in_habit_applied_to_problemsolving,
            selfcompassion_scaleshort_form, brooding_scale2_items, selfefficacymastery, problem_clarification_819b84)

  
for (i in seq(1,8)) {
  for (j in seq(1,length(.wk_dfs))) {
    .temp_data1 <- merge(.wk_data[[i]][1:2], select(filter(as.data.frame(.wk_dfs[j]), grepl(as.character(i), redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.wk_dfs[j])[ncol(as.data.frame(.wk_dfs[j]))])), by = "record_id", all = TRUE)
    .temp_data1 <- inner_join(.wk_data[[i]], .temp_data1, by = "record_id", multiple = "any")
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 2] <- "Incomplete form (over timepoint window and blocked)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 1] <- "Incomplete form (within timepoint window)"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 0] <- "Incomplete form (has not reached timepoint)"
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
    .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
    .wk_data[[i]] <- inner_join(.wk_data[[i]], select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
    
  }
  .wk_data[[i]][3][is.na(.wk_data[[i]][ncol(.wk_data[[i]])])] <- .scr_id$.trialno_wor[is.na(.wk_data[[i]][ncol(.wk_data[[i]])])]
  .wk_data[[i]][is.na(.wk_data[[i]]["record_id"]),] <- NA
}

colnames(.induc1_wor) <- "record_id"
.exc2_wor <- merge(.induc1_wor, filter(use_of_services_treatment_received_nhs, grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_received_nhs_complete")
.exc2_wor <- inner_join(.induc1_wor, .exc2_wor, by = "record_id", multiple = "any")
.exc2_wor[2][.exc2_wor[2] == "Incomplete"] <- NA
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 2] <- "Incomplete form (over timepoint window and blocked)"
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 1] <- "Incomplete form (within timepoint window)"
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 0] <- "Incomplete form (has not reached timepoint)"
.exc2_wor[2][.exc2_wor[2] == "Complete"] <- NA
.exc2_wor[2][is.na(.exc2_wor[1])] <- NA
.exc2_wor <- .exc2_wor[2]

colnames(.induc1_wor) <- ".induc1_wor"
colnames(.exc2_wor) <- ".exc2_wor"

.induc2_wor <- rep(NA, .N)
.induc2_wor[is.na(.exc2_wor)] <- .trialno_wor[is.na(.exc2_wor)]
.induc2_wor <- as.data.frame(.induc2_wor)
.exc2_wor[is.na(.induc1_wor)] <- NA

colnames(.induc2_wor) <- "record_id"
.exc3_wor <- merge(.induc2_wor, filter(use_of_services_treatment_received_nhs_12_month_fu, grepl("12m followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_received_nhs_12_month_fu_complete")
.exc3_wor <- inner_join(.induc2_wor, .exc3_wor, by = "record_id", multiple = "any")
.exc3_wor[2][.exc3_wor[2] == "Incomplete"] <- NA
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 2] <- "Incomplete form (over timepoint window and blocked)"
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 1] <- "Incomplete form (within timepoint window)"
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 0] <- "Incomplete form (has not reached timepoint)"
.exc3_wor[2][.exc3_wor[2] == "Complete"] <- NA
.exc3_wor[2][is.na(.exc3_wor[1])] <- NA
.exc3_wor <- .exc3_wor[2]

colnames(.induc2_wor) <- ".induc2_wor"
colnames(.exc3_wor) <- ".exc3_wor"

.induc3_wor <- rep(NA, .N)
.induc3_wor[is.na(.exc3_wor)] <- .scr_id$.trialno_wor[is.na(.exc3_wor)]
.induc3_wor <- as.data.frame(.induc3_wor)
.exc3_wor[is.na(.induc2_wor)] <- NA

.df <- data.frame(.scr_id, .exc1_wor, .induc1_wor, .arm_wor, .exc2_wor, .induc2_wor, .exc3_wor, .induc3_wor)
.df_wor <- merge(.df_con, .df, by = ".trialno", all = TRUE)

.df_wor$.arm[.df_wor$.arm == "Reducing Worry" & is.na(.df_wor$.trialno_wor)] <- "Consented but did not start baseline"
.df_wor$.arm[.df_wor$.arm == "Reducing Worry"] <- NA
.df_wor$.arm[.df_wor$.arm == "Bounce Back" | .df_wor$.arm == "Internet CBT"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: consort_plot
#| output: false

.out_wor <- consort_plot(data = .df_wor,
                    orders = c(.induc3 = "Consented to participate",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_wor = "Started Baseline",
                               .exc1_wor = "Incomplete Baseline Status",
                               .arm_wor = "Participant Randomised",
                               .exc2_wor = "Lost to Follow Up",
                               .induc2_wor = "3 Month Follow Up",
                               .exc3_wor = "Lost to Follow Up",
                               .induc3_wor = "12 Month Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_wor", ".exc2_wor", ".exc3_wor"),
                    labels = c("1" = "Given access to Reducing Worry",
                               "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

cat(build_grviz(.out_wor), file = "consort_wor.gv")

```

```{dot}
//| label: fig-consort_wor
//| fig-cap: "CONSORT diagram of NURTURE-U Reducing Worry."
//| file: consort_wor.gv
```
