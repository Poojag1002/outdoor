---
title: "Internet CBT TSC Report"
date-modified: today
format: html
embed-resources: true
execute:
  echo: false
  warning: false
tbl-cap-location: top
toc: true
toc-depth: 3
toc-title: "Reports:"
title-block-banner: true
---
```{r}
devtools::install_github("apalmerwelsh/CT_R_Package",
                         ref = "main",
                         auth_token = Sys.getenv("github_token")                          
                        )

```

```{r}
#| label: data_import_scr
#| output: false

library(tidyREDCap)
library(tidyverse)
library(expss)

rm(list = ls()) # Ensures workspace is clear before starting.

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("nurture_u_key"), # API Token.
  record_id = "screening_id", # Tells R the label of the Record ID on REDCap.
  drop_blank = FALSE
)
```

```{r}
#| label: data_save_scr
#| output: false

###-----------------------------------------------------------------------------
### Variables
# Replace with the desired filename, date should be included in filename.
.file_name <- paste("TSC_SCR_", Sys.Date(), ".RData", sep = "")

# Replace with the desired file path to save in. Ensure the path ends in "/".
.file_path <- "C:/Users/ap1114/OneDrive - University of Exeter/Documents/Trials/NURTURE-U/Data/"
###-----------------------------------------------------------------------------

##------------------------------------------------------------------------------
## Code

# This saves every dataframe currently loaded. If ran just after importing data that should just be the CRFs from REDCap.
save(list = ls(), file = paste(.file_path, .file_name, sep=""))
##------------------------------------------------------------------------------

```

```{r}
#| label: consort_data_scr
#| output: false

library(consort)
.N <- nrow(nurtureu_introduction)


.trialno <- nurtureu_introduction$screening_id

.exc1 <- rep(NA, .N)
.exc1 <- ifelse(nurtureu_introduction$nurtureu_introduction_complete == "Incomplete", "Did not complete basic eligibility form", NA)
.exc1 <- ifelse(nurtureu_introduction$intro_ineligible == 1, NA, "Did not meet basic eligibility criteria")

.induc1 <- rep(NA, .N)
.induc1[is.na(.exc1)] <- .trialno[is.na(.exc1)]

.exc2 <- rep(NA, .N)
.exc2[nurture_u_consent_for_screening$nurture_u_consent_for_screening_complete == "Incomplete"] <- "Did not complete consent form" 

.induc2 <- rep(NA, .N)
.induc2[is.na(.exc2)] <- .trialno[is.na(.exc2)]

.exc3 <- rep(NA, .N)
.exc3[grepl("Incomplete", lidas_adapted$lidas_adapted_complete, ignore.case = TRUE)] <- "Did not complete screening forms"
.exc3[grepl("Deviat", .trialno, ignore.case = TRUE)] <- "Deviated Participant*"
.exc3[is.na(.exc3)] <- ifelse(consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete[is.na(.exc3)] == "Incomplete" &
         consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete[is.na(.exc3)] == "Incomplete", 
         "Eligible but did not consent", .exc3[is.na(.exc3)])
.exc3[!grepl("Incomplete", ineligible$ineligible_complete, ignore.case = TRUE)] <- "Did not meet detailed eligibility criteria***"
.exc3[grepl("Duplicated", .trialno, ignore.case = TRUE)] <- "Duplicated participant**"

.induc3 <- rep(NA, .N)
.induc3[is.na(.exc3)] <- .trialno[is.na(.exc3)]

.arm <- rep(NA, .N)
.arm[!is.na(.induc3) & (consent_for_bounce_back_trial$consent_for_bounce_back_trial_complete == "Complete")] <- "Bounce Back"
.arm[!is.na(.induc3) & (consent_for_internetcbt_trial$consent_for_internetcbt_trial_complete == "Complete")] <- "Internet CBT"
.arm[!is.na(.induc3) & (consent_for_reduce_worry_trial$consent_for_reduce_worry_trial_complete == "Complete")] <- "Reducing Worry"

.phq9 <- rep(NA, .N)
.phq9[!is.na(.induc3)] <- phq9$phq_9_total[!is.na(.induc3)]

.gad7 <- rep(NA, .N)
.gad7[!is.na(.induc3)] <- gad7$gad_7_total[!is.na(.induc3)]

.lidas <- rep(NA, .N)
.lidas[!is.na(.induc3)] <- lidas_adapted$lidas_meet_mde[!is.na(.induc3)]

.pswq <- rep(NA, .N)
.pswq[!is.na(.induc3)] <- shortform_penn_state_worry_questionnaire$pswq_8_total[!is.na(.induc3)]

.brood <- rep(NA, .N)
.brood[!is.na(.induc3)] <- item_brooding_scale$bro_5_total[!is.na(.induc3)]

#.pri_out <- data.frame(.induc3, .arm, .phq9, .gad7, .lidas)
.arm2 <- .arm
.df_con <- data.frame(.trialno, .exc1, .induc1, .exc2, .induc2, .exc3, .induc3, .arm, .arm2, .phq9, .gad7, .lidas)

```

```{r}
#| label: consort_scr
#| output: false

# Constructs Consort Diagram for pooled data.
.out_scr <- consort_plot(data = .df_con,
                    orders = c(.trialno = "Participants accessed REDCap Survey",
                               .exc1    = "Incomplete Form Status",
                               .induc1 = "Accessed Consent Form A",
                               .exc2    = "Incomplete Consent Form A Status",
                               .induc2 = "Consented to Screening",
                               .exc3    = "Incomplete Screening Form Status",
                               .arm = "Consented to Consent Form B",
                               .induc3 = "Participant given access to trial baseline survey"
                               ),
                    side_box = c(".exc1", ".exc2", ".exc3"),
                    allocation = ".arm",
                    labels = c("1" = "Pre-Screening Eligibility Form",
                               "2" = "Pre-Screening",
                               "3" = "Screening", 
                               "5" = "Allocated to trial",
                               "6" = "Given access to trial"),
                    cex = 0.9)

# Creates plot file.
cat(build_grviz(.out_scr), file = "consort_scr_tsc.gv")

```

## Screening

```{r}
#| label: data_cleaning_scr
#| output: false

# The following line creates a list of dataframes. This allows - in this case - for duplicates to be removed from all instrument records.
.df_list <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.

# The following applies a filter to each instrument to remove duplicates.
.df_list <- .df_list %>% 
  lapply(function(x) filter(x,!grepl("Duplicated", screening_id, ignore.case = TRUE)))

# The following applies the changes back to the global environment.
names(.df_list) <- set_names(ls(all.names = FALSE))
list2env(.df_list, envir = .GlobalEnv)

```

```{r}
#| label: tbl-start_eli
#| tbl-cap: "Summary of Screening Introduction Outcomes."

nurtureu_introduction = apply_labels(nurtureu_introduction, intro_ineligible = "Eligibility") # Applies a label to the intro_ineligible column name.
nurtureu_introduction$intro_ineligible[nurtureu_introduction$intro_ineligible == 1] <- "Eligible" # Renames the variables, this allows for better presentation in the table.
nurtureu_introduction$intro_ineligible[nurtureu_introduction$intro_ineligible == 999] <- "Ineligible" # Renames the variables, this allows for better presentation in the table.

# Visualisation.
make_choose_one_table(nurtureu_introduction$intro_ineligible, subset = FALSE) %>% # Pipes the required data for the table.
  knitr::kable(col.names = c("Response","No. of Responses","Percent (%)"), align = 'lrr') # Creates a table to show the data and sets column names and positions.

```



```{r}
#| label: fig-start_con
#| fig-cap: "Summary of Screening Introduction Consent (excludes participants who were identified as ineligible during the Introduction CRF)."

## NOTE: This chunk requires the previous chunk to be run to work! ##

# The following filters out participants who were found ineligible after pre-screening.
.df_list <- .df_list %>% 
  lapply(function(x) filter(x,!grepl("Ineligible", nurtureu_introduction$intro_ineligible, ignore.case = TRUE)))
list2env(.df_list, envir = .GlobalEnv)

.high <- nurture_u_consent_for_screening %>% group_by(nurture_u_consent_for_screening_complete) %>% 
  summarise(count = n()) %>%
  select(count) %>%
  max()

.higher <- .high + ceiling(.high/10)

#Visualisation.
nurture_u_consent_for_screening %>% ggplot(aes(x=nurture_u_consent_for_screening_complete, fill=nurture_u_consent_for_screening_complete))+ # Creates the axes for the graph.
  geom_bar(stat="count", width=0.7)+ # Creates the bar graph.
  guides(fill = "none") + # Removes the legend created by "fill =" in ggplot().
  coord_flip(ylim = c(0, .higher)) + # Flips the x and y axes and sets a limit to fit the data.
  geom_text(aes(label = after_stat(count)), stat = "count", hjust = -1, colour = "black")+ # Creates labels above each column showing amount of responses for each option.
  theme_minimal()+ # Sets the theme for the graph.
  scale_y_continuous(breaks=seq(0,.higher,25)) + # Sets the tick values to fit the data.
  labs(y = "Number of Participants", x = "Consent status", # Sets axes labels.
       title = sprintf("Have the participants (n = %s) \nconsented to Screening?",nrow(nurture_u_consent_for_screening))) + # Sets title for graph with dynamic count of participants.
  theme( # Controls appearance of graph elements.
    axis.text.x = element_text(size = 14), # Sets size of x ticks (note due to coord_flip() this effects what is shown as the y axis).
    axis.text.y = element_text(size = 14), # Sets size of y ticks (note due to coord_flip() this effects what is shown as the x axis).
    plot.title = element_text(size = 20),  # Sets size of the graph title.
    axis.title.x = element_text(size = 18), # Sets size of x axis title (note due to coord_flip() this effects what is shown as the y axis).
    axis.title.y = element_text(size = 18)) # Sets size of y axis title (note due to coord_flip() this effects what is shown as the x axis).

```

```{r}
.scr_con_comp_plot <- CTUReportTool::ct_choose_one_plot(nurture_u_consent_for_screening, nurture_u_consent_for_screening_complete, title = sprintf("Have the participants (n = %s) \nconsented to Screening?",nrow(nurture_u_consent_for_screening)), y = "Number of Participants", x = "Consent status")

```

```{r}
#| label: fig-scr_consent
#| fig-cap: "Consent status at end of screening summary (excludes participants who were identified as ineligible during the Introduction CRF)."

# The following filters out participants who were found ineligible after pre-screening.
.df_list <- .df_list %>% 
  lapply(function(x) filter(x,!grepl("Ineligible", nurtureu_introduction$intro_ineligible, ignore.case = TRUE)))
list2env(.df_list, envir = .GlobalEnv)

# The following combines the required data to find all the outcomes for screening.
.df <- merge(select(ineligible,c("screening_id","ineligible_complete")), 
      select(consent_for_bounce_back_trial,
             c("screening_id","consent_for_bounce_back_trial_complete")),
      by = "screening_id") %>%
  merge(select(consent_for_internetcbt_trial,
               c("screening_id","consent_for_internetcbt_trial_complete")),
        by = "screening_id") %>%
  merge(select(consent_for_reduce_worry_trial,
               c("screening_id","consent_for_reduce_worry_trial_complete")),
        by = "screening_id")

# Converts data into binary values, allows "count" in geom_col() to work.
.df[c(2,3,4,5)] <- ifelse(.df[c(2,3,4,5)] == "Complete", 1, 0)

# Renames columns for presentation in graph.
.df <- .df %>% 
  rename("Consent for Bounce Back" = "consent_for_bounce_back_trial_complete") %>%
  rename("Consent for Internet CBT" = "consent_for_internetcbt_trial_complete") %>%
  rename("Consent for Reducing Worry" = "consent_for_reduce_worry_trial_complete") %>%
  rename("Ineligible" = "ineligible_complete")

# Converts data into "long" format, which is easier for R to visualise.
.long_df <- pivot_longer(.df, cols = (2:length(.df)), names_to = "Consent", values_to="Count") 

.high <- .long_df %>% group_by(Count, Consent) %>% 
  summarise(count2 = n()) %>%
  filter(Count == 1) %>%
  select(count2) %>%
  max()

.higher <- .high + ceiling(.high/10)

# Visualisation.
.long_df %>% ggplot(aes(x=Consent,y = Count, fill = Consent)) + # Provides variables for the plot to use and ensures that the colour of each bar is different.
  geom_col() + # Creates the basic column chart showing the amount of participants that have consented to each study.
  guides(fill = "none") + # Removes the legend created by "fill = Factor".
  coord_flip(ylim = c(0,.higher)) +
  geom_text( # geom_text controls all of the text for the chart.
    aes(label = after_stat(y), group = Consent), 
    stat = 'summary', fun = sum, hjust = -1
  ) + # These lines create the floating counts above each bar.
  theme_minimal()+ # Sets theme for the graph
  labs(y = "Number of Participants", x = "Consent Status", # Sets labels for x and y axis.
       title = sprintf("Participant Count (n = %s)",nrow(.df)), subtitle = "By Consent Status")+ # Creates titles for graph including a dynamic count of participants.
  theme( # Controls appearances for the graph.
        axis.text.x = element_text(size = 12), # Controls settings for ticks on the x-axis.
        plot.title = element_text(size = 20), # Controls settings for text in the title.
        plot.subtitle = element_text(size = 16), # Controls settings for text in the subtitle.
        axis.title.x = element_text(size = 18), # Controls settings for the x-axis label.
        axis.title.y = element_text(size = 18)) # Controls settings for the y-axis label.

```

```{r}
#| label: data_import_bb_1
#| output: false

rm(list = ls()) # Ensures workspace is empty before importing data.

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("bounce_back_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NB_1 (Duplicate)"
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
#.df_list <- list(academic_grades_selfreport,brief_resilience_scale,contact_details,
#                 demographics, gad7_fu, imported_fields, phq9_fu, randomisation,
#                 risk_contact_fu, trial_management_crf, 
#                 use_of_services_treatment_receivedincorporating_nh, wemwbs,
#                 withdrawal, wsas)

.dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.
names(.dfs) <- set_names(ls(all.names = FALSE))

```

```{r}
#| label: data_save_bb
#| output: false

###-----------------------------------------------------------------------------
### Variables
# Replace with the desired filename, date should be included in filename.
.file_name <- paste("TSC_BB_", Sys.Date(), ".RData", sep = "")

# Replace with the desired file path to save in. Ensure the path ends in "/".
.file_path <- "C:/Users/ap1114/OneDrive - University of Exeter/Documents/Trials/NURTURE-U/Data/"
###-----------------------------------------------------------------------------

##------------------------------------------------------------------------------
## Code

# This saves every dataframe currently loaded. If ran just after importing data that should just be the CRFs from REDCap.
save(list = ls(), file = paste(.file_path, .file_name, sep=""))
##------------------------------------------------------------------------------

```

```{r}
#| label: data_filter
#| output: false

# The following filters out duplicate entries from the CRF data.
.df_list <- .dfs %>% 
  lapply(function(x) filter(x,!grepl("Duplicate", record_id, ignore.case = TRUE)))
names(.df_list) <- set_names(ls(all.names = FALSE))
list2env(.df_list, envir = .GlobalEnv)

```

```{r}
#| label: rand_filter
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]
```

```{r}
#| label: Consort_bb_data
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_bb <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_bb")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()

.exc1_bb <- rep(NA, .N)
.exc1_bb[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") > 14] <- "Incomplete form (Blocked)"
.exc1_bb[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") <= 14] <- "Within timepoint window"

# List of participants who have finished Baseline.
.induc1_bb <- rep(NA, .N)
.induc1_bb[is.na(.exc1_bb)] <- .scr_id$.trialno_bb[is.na(.exc1_bb)]
.induc1_bb <- as.data.frame(.induc1_bb)

# Identifies which arm each participant has been allocated to.
.arm_bb <- rep(NA, .N)
.arm_bb[!is.na(.induc1_bb)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_bb[!is.na(.induc1_bb)] <- ifelse(grepl(.arm_b,.arm_bb[!is.na(.arm_bb)]), "Arm B", "Arm A")

# Finds participants who have not completed the 6 week follow up.
colnames(.induc1_bb) <- "record_id"
.exc2_bb <- merge(.induc1_bb, filter(use_of_services_treatment_receivedincorporating_nh, grepl("6", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_receivedincorporating_nh_complete")
.exc2_bb <- inner_join(.induc1_bb, .exc2_bb, by = "record_id", multiple = "any")
.exc2_bb[2][.exc2_bb[2] == "Incomplete"] <- NA
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 2] <- "Over timepoint window and blocked"
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 1] <- "Within timepoint window"
.exc2_bb[2][is.na(.exc2_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(6,7)) == 0] <- "Has not reached timepoint"
.exc2_bb[2][.exc2_bb[2] == "Complete"] <- NA
.exc2_bb[2][is.na(.exc2_bb[1])] <- NA
.exc2_bb <- .exc2_bb[2]

colnames(.induc1_bb) <- ".induc1_bb"
colnames(.exc2_bb) <- ".exc2_bb"

# List of participants who have completed 6 week follow up.
.induc2_bb <- rep(NA, .N)
.induc2_bb[is.na(.exc2_bb)] <- .trialno_bb[is.na(.exc2_bb)]
.induc2_bb <- as.data.frame(.induc2_bb)
.exc2_bb[is.na(.induc1_bb)] <- NA

colnames(.induc2_bb) <- "record_id"
.exc3_bb <- merge(.induc2_bb, filter(use_of_services_treatment_receivedincorporating_nh, grepl("12", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_receivedincorporating_nh_complete")
.exc3_bb <- inner_join(.induc2_bb, .exc3_bb, by = "record_id", multiple = "any")
.exc3_bb[2][.exc3_bb[2] == "Incomplete"] <- NA
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 2] <- "Over timepoint window and blocked"
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 1] <- "Within timepoint window"
.exc3_bb[2][is.na(.exc3_bb[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 0] <- "Has not reached timepoint"
.exc3_bb[2][.exc3_bb[2] == "Complete"] <- NA
.exc3_bb[2][is.na(.exc3_bb[1])] <- NA
.exc3_bb <- .exc3_bb[2]

colnames(.induc2_bb) <- ".induc2_bb"
colnames(.exc3_bb) <- ".exc3_bb"

# List of participants who have completed 12 week follow up.
.induc3_bb <- rep(NA, .N)
.induc3_bb[is.na(.exc3_bb)] <- .scr_id$.trialno_bb[is.na(.exc3_bb)]
.induc3_bb <- as.data.frame(.induc3_bb)
.exc3_bb[is.na(.induc2_bb)] <- NA

.df <- data.frame(.scr_id, .exc1_bb, .induc1_bb, .arm_bb, .exc2_bb, .induc2_bb, .exc3_bb, .induc3_bb)
.df_bb <- merge(.df_con, .df, by = ".trialno", all = TRUE)
.df_bb$.arm[.df_bb$.arm == "Bounce Back" & is.na(.df_bb$.trialno_bb)] <- "Consented but did not start baseline"
.df_bb$.arm[.df_bb$.arm == "Bounce Back"] <- NA
.df_bb$.arm[.df_bb$.arm == "Internet CBT" | .df_bb$.arm == "Reducing Worry"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: Consort_bb
#| output: false

.out_bb <- consort_plot(data = .df_bb,
                    orders = c(.induc3 = "Consented to Consent Form B",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_bb = "Started Baseline",
                               .exc1_bb = "Incomplete Baseline Status",
                               .arm_bb = "Patient randomised",
                               .exc2_bb = "Incomplete Follow Up Status",
                               .induc2_bb = "6 Week Follow Up",
                               .exc3_bb = "Incomplete Follow Up Status",
                               .induc3_bb = "12 Week Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_bb", ".exc2_bb", ".exc3_bb"),
                    labels = c("1" = "Given access to Bounce Back", "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

cat(build_grviz(.out_bb), file = "consort_bb_tsc.gv")

```

```{r}
#| label: data_import_wor_1
#| output: false

library(tidyREDCap)
library(tidyverse)
library(expss)

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("reduce_worry_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NR_1",
  drop_blank = FALSE
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
.dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.
names(.dfs) <- set_names(ls(all.names = FALSE))

#.df_list <- list(academic_grades_selfreport, brief_resilience_scale, brooding_scale2_items, change_in_habit_applied_to_problemsolving, change_in_habit_applied_to_worry_61f68e, contact_details, demographics, imported_fields, negative_experience_measure, perceived_stress_scale, phq2_gad2, problem_clarification_819b84, pssi, randomisation, selfcompassion_scaleshort_form, selfefficacymastery, stress, trial_management_crf, use_of_cognitive_and_behavioural_skills, use_of_services_treatment_received_nhs, wemwbs, withdrawal, wsas)

```

```{r}
#| label: data_save_wor
#| output: false

###-----------------------------------------------------------------------------
### Variables
# Replace with the desired filename, date should be included in filename.
.file_name <- paste("TSC_WOR_", Sys.Date(), ".RData", sep = "")

# Replace with the desired file path to save in. Ensure the path ends in "/".
.file_path <- "C:/Users/ap1114/OneDrive - University of Exeter/Documents/Trials/NURTURE-U/Data/"
###-----------------------------------------------------------------------------

##------------------------------------------------------------------------------
## Code

# This saves every dataframe currently loaded. If ran just after importing data that should just be the CRFs from REDCap.
save(list = ls(), file = paste(.file_path, .file_name, sep=""))
##------------------------------------------------------------------------------

```

```{r}
#| label: rand_alloc_wor
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]

```

```{r}
#| label: consort_data_wor
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_wor <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_wor")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()


.exc1_wor <- rep(NA, .N)
.exc1_wor[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") > 14] <- "Incomplete form (blocked)"
.exc1_wor[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$con_start_dt, units = "days") <= 14] <- "Within timepoint window"

# List of participants who have finished Baseline.
.induc1_wor <- rep(NA, .N)
.induc1_wor[is.na(.exc1_wor)] <- .scr_id$.trialno_wor[is.na(.exc1_wor)]
.induc1_wor <- as.data.frame(.induc1_wor)

# Identifies which arm each participant has been allocated to.
.arm_wor <- rep(NA, .N)
.arm_wor[!is.na(.induc1_wor)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_wor[!is.na(.induc1_wor)] <- ifelse(grepl(.arm_a,.arm_wor[!is.na(.arm_wor)]), "Arm A", "Arm B")

# Weekly Data
colnames(.induc1_wor) <- "record_id"
.wk_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_rum_timepoint == "Between baseline to next follow-up assessment")
.wk_withdraw <- merge(.induc1_wor, select(.wk_withdraw, "record_id", "with_rum_ch_dt"), by = "record_id", all = TRUE)
.wk_withdraw <- inner_join(.induc1_wor, .wk_withdraw, by = "record_id", multiple = "any")
.wk_withdraw <- mutate(.wk_withdraw, .wk_comp = NA)

.wk_data <- lapply (1 : 9, function (x)  data.frame(.wk_withdraw))
.wk_dfs <- list(phq2_gad2, stress, use_of_cognitive_and_behavioural_skills, change_in_habit_applied_to_worry_61f68e ,change_in_habit_applied_to_problemsolving,
            selfcompassion_scaleshort_form, brooding_scale2_items, selfefficacymastery, problem_clarification_819b84)

  
for (i in seq(1,8)) {
  for (j in seq(1,length(.wk_dfs))) {
    .temp_data1 <- merge(.wk_data[[i]][1:2], select(filter(as.data.frame(.wk_dfs[j]), grepl(as.character(i), redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.wk_dfs[j])[ncol(as.data.frame(.wk_dfs[j]))])), by = "record_id", all = TRUE)
    .temp_data1 <- inner_join(.wk_data[[i]], .temp_data1, by = "record_id", multiple = "any")
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 2] <- "Over timepoint window and blocked"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 1] <- "Within timepoint window"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 0] <- "Has not reached timepoint"
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
    .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
    .wk_data[[i]] <- inner_join(.wk_data[[i]], select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
    
  }
  .wk_data[[i]][3][is.na(.wk_data[[i]][ncol(.wk_data[[i]])])] <- .scr_id$.trialno_wor[is.na(.wk_data[[i]][ncol(.wk_data[[i]])])]
  .wk_data[[i]][is.na(.wk_data[[i]]["record_id"]),] <- NA
}

colnames(.induc1_wor) <- "record_id"
.exc2_wor <- merge(.induc1_wor, filter(use_of_services_treatment_received_nhs, grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_received_nhs_complete")
.exc2_wor <- inner_join(.induc1_wor, .exc2_wor, by = "record_id", multiple = "any")
.exc2_wor[2][.exc2_wor[2] == "Incomplete"] <- NA
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 2] <- "Over timepoint window and blocked"
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 1] <- "Within timepoint window"
.exc2_wor[2][is.na(.exc2_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(12,13)) == 0] <- "Has not reached timepoint"
.exc2_wor[2][.exc2_wor[2] == "Complete"] <- NA
.exc2_wor[2][is.na(.exc2_wor[1])] <- NA
.exc2_wor <- .exc2_wor[2]

colnames(.induc1_wor) <- ".induc1_wor"
colnames(.exc2_wor) <- ".exc2_wor"

.induc2_wor <- rep(NA, .N)
.induc2_wor[is.na(.exc2_wor)] <- .trialno_wor[is.na(.exc2_wor)]
.induc2_wor <- as.data.frame(.induc2_wor)
.exc2_wor[is.na(.induc1_wor)] <- NA

colnames(.induc2_wor) <- "record_id"
.exc3_wor <- merge(.induc2_wor, filter(use_of_services_treatment_received_nhs_12_month_fu, grepl("12m followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "use_of_services_treatment_received_nhs_12_month_fu_complete")
.exc3_wor <- inner_join(.induc2_wor, .exc3_wor, by = "record_id", multiple = "any")
.exc3_wor[2][.exc3_wor[2] == "Incomplete"] <- NA
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 2] <- "Over timepoint window and blocked"
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 1] <- "Within timepoint window"
.exc3_wor[2][is.na(.exc3_wor[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(52,53)) == 0] <- "Has not reached timepoint"
.exc3_wor[2][.exc3_wor[2] == "Complete"] <- NA
.exc3_wor[2][is.na(.exc3_wor[1])] <- NA
.exc3_wor <- .exc3_wor[2]

colnames(.induc2_wor) <- ".induc2_wor"
colnames(.exc3_wor) <- ".exc3_wor"

.induc3_wor <- rep(NA, .N)
.induc3_wor[is.na(.exc3_wor)] <- .scr_id$.trialno_wor[is.na(.exc3_wor)]
.induc3_wor <- as.data.frame(.induc3_wor)
.exc3_wor[is.na(.induc2_wor)] <- NA

.df <- data.frame(.scr_id, .exc1_wor, .induc1_wor, .arm_wor, .exc2_wor, .induc2_wor, .exc3_wor, .induc3_wor)
.df_wor <- merge(.df_con, .df, by = ".trialno", all = TRUE)

.df_wor$.arm[.df_wor$.arm == "Reducing Worry" & is.na(.df_wor$.trialno_wor)] <- "Consented but did not start baseline"
.df_wor$.arm[.df_wor$.arm == "Reducing Worry"] <- NA
.df_wor$.arm[.df_wor$.arm == "Bounce Back" | .df_wor$.arm == "Internet CBT"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: consort_plot
#| output: false

.out_wor <- consort_plot(data = .df_wor,
                    orders = c(.induc3 = "Consented to Consent Form B",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_wor = "Started Baseline",
                               .exc1_wor = "Incomplete Baseline Status",
                               .arm_wor = "Participant Randomised",
                               .exc2_wor = "Incomplete Follow Up Status",
                               .induc2_wor = "3 Month Follow Up",
                               .exc3_wor = "Incomplete Follow Up Status",
                               .induc3_wor = "12 Month Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_wor", ".exc2_wor", ".exc3_wor"),
                    labels = c("1" = "Given access to Reducing Worry",
                               "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

cat(build_grviz(.out_wor), file = "consort_wor_tsc.gv")

```

```{r}
#| label: data_import_cbt
#| output: false

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("internet_cbt_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NA_1",
  drop_blank = FALSE
)

# The following creates a list of CRF data frames, this allows for a filter to be applied to each CRF at once.
#.df_list <- list(academic_grades_selfreport, ae, apoi, audit, brief_resilience_scale, brooding_scale2_items, change_in_habit_applied_to_problemsolving, change_in_habit_applied_to_worry_61f68e, childhood_experience_of_care_and_abuse, cidisc, contact_details, demographics, imported_fields, motivation_to_change, negative_experience_measure, perceived_stress_scale, personality_measures, phq2_gad2, physical_health_and_lifestyle_questions, problem_clarification_819b84, problem_description, problemsolving_skills, promiss_applied_cognition_abilities_scale, pssi, randomisation, relationship_questionnaire, risk_contactbaseline, rosenberg_self_esteem, sci_sleep_condition_indicator, selfcompassion_scaleshort_form, selfcontrol, selfefficacymastery, social_support_and_social_competence, stress, substance_abuse, suicidality, therapy_expectation, therapy_preference_and_expectancy, trial_management_crf, ucla_loneliness_scale_4item, use_of_cognitive_and_behavioural_skills, use_of_services_treatment_receivedincorporating_nh, wemwbs, withdrawal, wsas)

```

```{r}
#| label: data_save_cbt_1
#| output: false

###-----------------------------------------------------------------------------
### Variables
# Replace with the desired filename, date should be included in filename.
.file_name <- paste("TSC_CBT_1_", Sys.Date(), ".RData", sep = "")

# Replace with the desired file path to save in. Ensure the path ends in "/".
.file_path <- "C:/Users/ap1114/OneDrive - University of Exeter/Documents/Trials/NURTURE-U/Data/"
###-----------------------------------------------------------------------------

##------------------------------------------------------------------------------
## Code

# This saves every dataframe currently loaded. If ran just after importing data that should just be the CRFs from REDCap.
save(list = ls(), file = paste(.file_path, .file_name, sep=""))
##------------------------------------------------------------------------------

```

```{r}
#| label: rand_alloc
#| output: false

.rand_choice <- na.omit(randomisation$rando_allocation)[!duplicated(randomisation$rando_allocation)]

.arm_a <- .rand_choice[1]
.arm_b <- .rand_choice[2]

```

```{r}
#| label: consort_cbt_data
#| output: false

# Gives number of participants.
.N <- nrow(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)))

# Retrieves both record and screening ID for each participant.
.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.scr_id <- select(filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "screening_id" , "record_id")
colnames(.scr_id) <- c(".trialno", ".trialno_cbt")

# Finds participants who have not completed baseline and their current status.
.rando_dt <- drop_all_labels(filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_dt) 
.rando_dt[is.na(.rando_dt)] <- Sys.Date()

.exc1_cbt <- rep(NA, .N)
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") > 14] <- "(Blocked)"
.exc1_cbt[filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$randomisation_complete == "Incomplete" & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") <= 14] <- "Within timepoint window"

# List of participants who have finished Baseline.
.induc1_cbt <- rep(NA, .N)
.induc1_cbt[is.na(.exc1_cbt)] <- .scr_id$.trialno_cbt[is.na(.exc1_cbt)]
.induc1_cbt <- as.data.frame(.induc1_cbt)

# Identifies which arm each participant has been allocated to.
.arm_cbt <- rep(NA, .N)
.arm_cbt[!is.na(.induc1_cbt)] <- filter(randomisation, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$rando_allocation
.arm_cbt[!is.na(.induc1_cbt)] <- ifelse(grepl(.arm_a,.arm_cbt[!is.na(.arm_cbt)]), "Arm A", "Arm B")

# Weekly Data
colnames(.induc1_cbt) <- "record_id"
.wk_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_acu_timepoint == "Between baseline to final follow-up assessment")
.wk_withdraw <- merge(.induc1_cbt, select(.wk_withdraw, "record_id", "with_acu_ch_dt"), by = "record_id", all = TRUE)
.wk_withdraw <- inner_join(.induc1_cbt, .wk_withdraw, by = "record_id", multiple = "any")
.wk_withdraw <- mutate(.wk_withdraw, .wk_comp = NA)

.wk_data <- lapply (1 : 9, function (x)  data.frame(.wk_withdraw))
.wk_dfs <- list(phq2_gad2, stress, use_of_cognitive_and_behavioural_skills, change_in_habit_applied_to_worry_61f68e ,change_in_habit_applied_to_problemsolving,
            selfcompassion_scaleshort_form, brooding_scale2_items, selfefficacymastery, problem_clarification_819b84)

  
for (i in seq(1,8)) {
  for (j in seq(1,length(.wk_dfs))) {
    .temp_data1 <- merge(.wk_data[[i]][1:2], select(filter(as.data.frame(.wk_dfs[j]), grepl(as.character(i), redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.wk_dfs[j])[ncol(as.data.frame(.wk_dfs[j]))])), by = "record_id", all = TRUE)
    .temp_data1 <- inner_join(.wk_data[[i]], .temp_data1, by = "record_id", multiple = "any")
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 2] <- "Over timepoint window and blocked"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 1] <- "Within timepoint window"
    .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "weeks"), c(i,i+1)) == 0] <- "Has not reached timepoint"
    .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
    .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
    .wk_data[[i]] <- inner_join(.wk_data[[i]], select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
    
  }
  .wk_data[[i]][3][is.na(.wk_data[[i]][ncol(.wk_data[[i]])])] <- .scr_id$.trialno_cbt[is.na(.wk_data[[i]][ncol(.wk_data[[i]])])]
  .wk_data[[i]][is.na(.wk_data[[i]]["record_id"]),] <- NA
}

.wk_data_all <- .wk_data

# Finds participants who have not completed the 8 week follow up.
#.exc2_cbt <- merge(.induc1_cbt, filter(problem_clarification_819b84, grepl("8", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
#  select("record_id", "problem_clarification_819b84_complete")
#.exc2_cbt <- inner_join(.induc1_cbt, .exc2_cbt, by = "record_id", multiple = "any")
#.exc2_cbt[2][.exc2_cbt[2] == "Incomplete"] <- NA
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 2] <- "Over timepoint window and blocked"
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 1] <- "Within timepoint window"
#.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(56,63)) == 0] <- "Has not reached timepoint"
#.exc2_cbt[2][.exc2_cbt[2] == "Complete"] <- NA
#.exc2_cbt[2][is.na(.exc2_cbt[1])] <- NA
#.exc2_cbt <- .exc2_cbt[2]

#colnames(.induc1_cbt) <- ".induc1_cbt"
#colnames(.exc2_cbt) <- ".exc2_cbt"

# List of participants who have completed 8 week follow up.


# Finds participants who have not completed 3 month follow up.
#.exc2_cbt = rep(NA, .N)
colnames(.induc1_cbt) <- "record_id"
.exc2_cbt <- merge(.induc1_cbt, filter(open_text_questions_about_therapy, grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), by = "record_id", all = TRUE) %>%
  select("record_id", "open_text_questions_about_therapy_complete")
.exc2_cbt <- inner_join(.induc1_cbt, .exc2_cbt, by = "record_id", multiple = "any")
.exc2_cbt[2][.exc2_cbt[2] == "Incomplete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 2] <- "Over timepoint window and blocked"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 1] <- "Within timepoint window"
.exc2_cbt[2][is.na(.exc2_cbt[2]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 0] <- "Has not reached timepoint"
.exc2_cbt[2][.exc2_cbt[2] == "Complete"] <- NA
.exc2_cbt[2][is.na(.exc2_cbt[1])] <- NA
.exc2_cbt <- .exc2_cbt[2]

colnames(.induc1_cbt) <- ".induc1_cbt"
colnames(.exc2_cbt) <- ".exc2_cbt"

# List of participants who have completed 3 month follow up.
.induc2_cbt <- rep(NA, .N)
.induc2_cbt[is.na(.exc2_cbt)] <- .trialno_cbt[is.na(.exc2_cbt)]
.induc2_cbt <- as.data.frame(.induc2_cbt)
.exc2_cbt[is.na(.induc1_cbt)] <- NA
.induc2_cbt[is.na(.induc1_cbt)] <- NA

# Merges cbt data with screening data for complete timeline.
.df <- data.frame(.scr_id, .exc1_cbt, .induc1_cbt, .arm_cbt, .exc2_cbt, .induc2_cbt)
.df_cbt <- merge(.df_con, .df, by = ".trialno", all.x = TRUE)

# Changes the screening arm as only interested in Internet CBT here.
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & is.na(.df_cbt$.trialno_cbt)] <- "Consented but did not start baseline"
.df_cbt$.arm[.df_cbt$.arm == "Internet CBT" & !is.na(.df_cbt$.trialno_cbt)] <- NA
.df_cbt$.arm[.df_cbt$.arm == "Bounce Back" | .df_cbt$.arm == "Reducing Worry"] <- "Consented to other NURTURE-U Trial"

```

```{r}
#| label: consort_cbt_pool
#| output: false

# Constructs Consort Diagram for pooled data.
.out_cbt <- consort_plot(data = .df_cbt,
                    orders = c(.induc3 = "Consented to Consent Form B",
                               .arm     = "Incomplete Baseline Status",
                               .trialno_cbt = "Started Baseline",
                               .exc1_cbt = "Incomplete Baseline Status",
                               .arm_cbt = "Participant Randomised",
                               .exc2_cbt = "Incomplete Follow Up Status",
                               .induc2_cbt = "3 Month Follow Up"
                               ),
                    side_box = c(".arm", ".exc1_cbt", ".exc2_cbt"),
                    labels = c("1" = "Given access to Internet CBT",
                               "2" = "Baseline", 
                               "3" = "Randomisation", 
                               "4" = "Follow up Period"),
                    cex = 0.9)

# Creates plot file.
cat(build_grviz(.out_cbt), file = "consort_cbt_tsc.gv")

```

```{dot}
//| label: fig-consort_scr_pool
//| fig-cap: "CONSORT diagram of NURTURE-U Screening Data (pooled data)."
//| file: consort_scr_tsc.gv
```

```{r}
#| label: Consort_scr_save
#| output: false
png("consort_diagram_scr_tsc.png", width = 35, 
    height = 20, res = 300, units = "cm", type = "cairo") 
plot(.out_scr)
dev.off() 
```

```{dot}
//| label: fig-consort_cbt
//| fig-cap: "CONSORT diagram of NURTURE-U Internet CBT (pooled data)."
//| file: consort_cbt_tsc.gv
```

```{r}
#| label: Consort_cbt_save
#| output: false
png("consort_diagram_cbt_tsc.png", width = 30, 
    height = 20, res = 300, units = "cm", type = "cairo") 
plot(.out_cbt)
dev.off() 
```

```{dot}
//| label: fig-consort_bb
//| fig-cap: "CONSORT diagram of NURTURE-U Bounce Back."
//| file: consort_bb_tsc.gv
```

```{r}
#| label: Consort_bb_save
#| output: false
png("consort_diagram_bb_tsc.png", width = 30, 
    height = 20, res = 300, units = "cm", type = "cairo") 
plot(.out_bb)
dev.off() 
```

```{dot}
//| label: fig-consort_wor
//| fig-cap: "CONSORT diagram of NURTURE-U Reducing Worry."
//| file: consort_wor_tsc.gv
```

```{r}
#| label: Consort_wor_save
#| output: false
png("consort_diagram_wor_tsc.png", width = 30, 
    height = 20, res = 300, units = "cm", type = "cairo") 
plot(.out_wor)
dev.off() 
```

```{r}
#| label: data_import_cbt_clean
#| output: false

rm(list = ls())

# Imports data from REDCap using API (Re-run this section to refresh the data).
tidyREDCap::import_instruments( # Tells R to import all instruments/CRFs used in the project.
  "https://rc.ctu.exeter.ac.uk/api/", # URL of the site to import from.
  Sys.getenv("internet_cbt_key"), # API Token.
  record_id = "record_id", # Tells R the label of the Record ID on REDCap.
  first_record_id = "NA_1"
)

dfs <- Filter(function(x) is(x, "data.frame"), mget(ls())) # Creates a list of CRFs. This allows for functions to be applied to all CRFs at once if needed.

```

```{r}
#| label: data_save_cbt_2
#| output: false

###-----------------------------------------------------------------------------
### Variables
# Replace with the desired filename, date should be included in filename.
.file_name <- paste("TSC_CBT_2_", Sys.Date(), ".RData", sep = "")

# Replace with the desired file path to save in. Ensure the path ends in "/".
.file_path <- "C:/Users/ap1114/OneDrive - University of Exeter/Documents/Trials/NURTURE-U/Data/"
###-----------------------------------------------------------------------------

##------------------------------------------------------------------------------
## Code

# This saves every dataframe currently loaded. If ran just after importing data that should just be the CRFs from REDCap.
save(list = ls(), file = paste(.file_path, .file_name, sep=""))
##------------------------------------------------------------------------------

```

```{r}

# Baseline Data

.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.trialno_cbt <- as.data.frame(.trialno_cbt)
colnames(.trialno_cbt) <- "record_id"

.base_withdraw <- filter(withdrawal,grepl("Unschedule Event", redcap_event_name, ignore.case = TRUE) & withdrawal_complete == "Complete" & with_acu_timepoint == "During Baseline")
.base_withdraw <- merge(.trialno_cbt, select(.base_withdraw, "record_id", "with_acu_ch_dt"), by = "record_id", all = TRUE)
.base_withdraw <- inner_join(.trialno_cbt, .base_withdraw, by = "record_id", multiple = "any")
.base_data <- mutate(.base_withdraw, .base_comp = NA)

.base_dfs <- list(contact_details, demographics, childhood_experience_of_care_and_abuse, wemwbs, perceived_stress_scale, pssi, negative_experience_measure, wsas, brief_resilience_scale, academic_grades_selfreport, use_of_services_treatment_receivedincorporating_nh, physical_health_and_lifestyle_questions, cidisc, suicidality, risk_contactbaseline, audit, substance_abuse, sci_sleep_condition_indicator, ucla_loneliness_scale_4item, social_support_and_social_competence, personality_measures, rosenberg_self_esteem, brief_measure_of_hopelessness, relationship_questionnaire, promiss_applied_cognition_abilities_scale, motivation_to_change, selfcontrol, therapy_preference_and_expectancy, apoi, problem_description, therapy_expectation, problemsolving_skills, randomisation, imported_fields)

for (j in seq(1,length(.base_dfs))) {
  .temp_data1 <- merge(.base_data[1], select(filter(as.data.frame(.base_dfs[j]), grepl("Baseline", redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.base_dfs[j])[ncol(as.data.frame(.base_dfs[j]))])), by = "record_id", all = TRUE)
  .temp_data1 <- inner_join(.base_data, .temp_data1, by = "record_id", multiple = "any")
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") > 14] <- "Over timepoint window and blocked"
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & difftime(.rando_dt, filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$cont_start_dt, units = "days") <= 14] <- "Within timepoint window"
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
  .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
  .base_data <- inner_join(.base_data, select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
}
.base_data[3][is.na(.base_data[ncol(.base_data)])] <- .scr_id$.trialno_cbt[is.na(.base_data[ncol(.base_data)])]
.base_data[is.na(.base_data["record_id"]),] <- NA

```

```{r}
#| label: bline_data_comp
#| output: false
#| 
.target_string <- c("Over timepoint window and blocked")

#.M <- as.matrix(.base_data)
#.M[,-(1:3)] <- ifelse(.M[,-(1:3)] == .target_string ,1,0)

is_present <- function(x) {
  x %in% .target_string 
}

.base_data_t <- as.data.frame(t(.base_data))
.base_data_t <- .base_data_t %>% 
  rowwise() %>% 
  mutate(num_over = sum(is_present(across(matches(colnames(.base_data_t))))))

.base_comp <- data.frame(crf = colnames(.base_data)[-(1:3)], num_exp = rep(nrow(.base_data),length(.base_data)-3), num_over = .base_data_t$num_over[-(1:3)])

```

```{r}
#| label: wk_data_comp
#| output: false

.wk_comp <- lapply (1 : 8, function (x)  data.frame())

.target_string <- c("Over timepoint window and blocked")

is_present <- function(x) {
  x %in% .target_string 
}

.wk_data_t <- as.data.frame(t(.wk_data[[1]]))
.wk_data_t <- .wk_data_t %>% 
  rowwise() %>% 
  mutate(num_over = sum(is_present(across(matches(colnames(.wk_data_t))))))

.wk_exp_filter <- filter(.wk_data[[1]], !is.na(.wk_data[[1]]$record_id) & (.wk_data[[1]]$problem_clarification_819b84_complete != "Has not reached timepoint" | is.na(.wk_data[[1]]$problem_clarification_819b84_complete)))

.wk_comp[[1]] <- data.frame(crf = colnames(.wk_data[[1]])[-(1:3)], num_exp = rep(nrow(.wk_exp_filter),length(.wk_data[[1]])-3), num_over = .wk_data_t$num_over[-(1:3)])

.wk_comp_total <- .wk_comp[[1]]
#,length(.wk_data)
for (i in seq(2,length(.wk_data)-1)) {
  .wk_data_t <- as.data.frame(t(.wk_data[[i]]))
  .wk_data_t <- .wk_data_t %>% 
    rowwise() %>% 
    mutate(num_over = sum(is_present(across(matches(colnames(.wk_data_t))))))

  .wk_exp_filter <- filter(.wk_data[[i]], !is.na(.wk_data[[i]]$record_id))
  .wk_exp_filter <- filter(.wk_exp_filter, (.wk_exp_filter$problem_clarification_819b84_complete != "Has not reached timepoint" | is.na(.wk_exp_filter$problem_clarification_819b84_complete)))
  
  .wk_comp[[i]] <- data.frame(crf = colnames(.wk_data[[i]])[-(1:3)], num_exp = rep(nrow(.wk_exp_filter),length(.wk_data[[i]])-3), num_over = .wk_data_t$num_over[-(1:3)])
  
  .wk_comp_total[2:3] <- .wk_comp_total[2:3] + .wk_comp[[i]][2:3]
}
#.wk_exp_filt <- filter(.wk_data[[1]], !is.na(.wk_data[[1]]$record_id) & (.wk_data[[1]]$problem_clarification_819b84_complete != "Incomplete (awaiting access)" | is.na(.wk_data[[1]]$problem_clarification_819b84_complete)))
#"Incomplete (awaiting access)"

```

```{r}
#| label: 3m_data
#| output: false

.fu_3m_dfs <- list(phq9_fu, risk_contact_fu, gad7_fu, item_brooding_scale_fu, shortform_penn_state_worry_questionnaires_fu, wemwbs, perceived_stress_scale, pssi, negative_experience_measure, wsas, brief_resilience_scale, academic_grades_selfreport, use_of_services_treatment_receivedincorporating_nh, use_and_application_of_intervention, adapted_client_satisfaction_with_treatment_questio, open_text_questions_about_therapy)

.trialno_cbt <- filter(contact_details, grepl("Baseline", redcap_event_name, ignore.case = TRUE))$record_id
.trialno_cbt <- as.data.frame(.trialno_cbt)
colnames(.trialno_cbt) <- "record_id"

.fu_3m_data <- mutate(.trialno_cbt, .fu_3m_comp = NA)

for (j in seq(1,length(.fu_3m_dfs))) {
  .temp_data1 <- merge(.fu_3m_data[1], select(filter(as.data.frame(.fu_3m_dfs[j]), grepl("3m Followup", redcap_event_name, ignore.case = TRUE)), "record_id", colnames(as.data.frame(.fu_3m_dfs[j])[ncol(as.data.frame(.fu_3m_dfs[j]))])), by = "record_id", all = TRUE)
  .temp_data1 <- inner_join(.fu_3m_data, .temp_data1, by = "record_id", multiple = "any")
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Incomplete"] <- NA 
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 2] <- "Incomplete (overdue)"
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 1] <- "Incomplete (awaiting data entry)"
  .temp_data1[ncol(.temp_data1)][is.na(.temp_data1[ncol(.temp_data1)]) & findInterval(difftime(Sys.Date(), .rando_dt, units = "days"), c(90,97)) == 0] <- "Incomplete (awaiting access)"
  .temp_data1[ncol(.temp_data1)][.temp_data1[ncol(.temp_data1)] == "Complete"] <- NA
  .temp_data1[ncol(.temp_data1)][!is.na(.temp_data1[2])] <- "Withdrawn"
  .fu_3m_data <- inner_join(.fu_3m_data, select(.temp_data1, "record_id", colnames(.temp_data1)[ncol(.temp_data1)]), by = "record_id", multiple = "any")
}
.fu_3m_data[2][is.na(.fu_3m_data[ncol(.fu_3m_data)])] <- .scr_id$.trialno_cbt[is.na(.fu_3m_data[ncol(.fu_3m_data)])]
.fu_3m_data[is.na(.fu_3m_data["record_id"]),] <- NA

```

```{r}
#| label: 3m_data_comp
#| output: false
#| 
.target_string <- c("Incomplete (overdue)")

is_present <- function(x) {
  x %in% .target_string 
}

.fu_3m_data_t <- as.data.frame(t(.fu_3m_data))
.fu_3m_data_t <- .fu_3m_data_t %>% 
  rowwise() %>% 
  mutate(num_over = sum(is_present(across(matches(colnames(.fu_3m_data_t))))))

.fu_3m_exp_filter <- filter(.fu_3m_data[1], !is.na(.fu_3m_data[1]) & (.fu_3m_data[length(.fu_3m_data)] != "Incomplete (awaiting access)" | is.na(.fu_3m_data[length(.fu_3m_data)])))

.fu_3m_comp <- data.frame(crf = colnames(.fu_3m_data)[-(1:2)], num_exp = rep(nrow(.fu_3m_exp_filter),length(.fu_3m_data)-2), num_over = .fu_3m_data_t$num_over[-(1:2)])

```

## Recruitment (Actual vs. Expected)

```{r}
#| label: fig-bline_recruit_cbt
#| fig-cap: "Summary of Internet CBT recuitment (Actual vs Expected)."

# The following groups the data by calender month and creates a cumulative count of the data.
.cum_count <- select(dfs$randomisation, c("record_id", "randomisation_complete", "rando_dt")) %>% 
  group_by(month = lubridate::floor_date(rando_dt, 'month')) %>% 
  summarise(count = n()) %>% 
  mutate(cum_count = cumsum(count)) %>% 
  ungroup
.cum_count <- na.omit(.cum_count)

# Creates a new variable used to differentiate between Actual and Expected data - used in ggplot().
.part_count <- .cum_count %>%
  mutate(state = "Actual")

# Creates a dataframe similiar to .part_count for Expected data. Data taken from Revised_actual_cumulative recruitment_v0.1.
.start_date <- as.Date("2023/07/01")
.exp_count <- data.frame(
  month = seq(.start_date, by = "month", length.out = 18),
  count = c(34,34,34,42,42,42,42,42,42,42,42,36,36,42,42,42,42,42)) %>%
  mutate(cum_count = cumsum(count)) %>%
  mutate(state = "Expected")

# Combines the Actual and Expected data.
.part_count_both <- rbind(.part_count, .exp_count)

.lower = 0 # Sets lower limit for primary y axis.
.higher = max(.part_count_both$count) + ceiling(max(.part_count_both$count)/10) # Sets upper limit for primary y axis.
.coeff = max(.part_count_both$cum_count)/.higher # This is used to scale the secondary y axis.

.int_breaks_rounded <- function(x, n = 5)  pretty(x, n)[round(pretty(x, n),1) %% 1 == 0]

#Visualisation.
ggplot(.part_count_both, aes(fill=state, y=cum_count/.coeff, x=month)) + # Selects data for the graph. Note the secondary y axis data is divided by .coeff so that it will fit the modified axis.
  geom_bar(position="dodge", stat="identity", alpha = .5) + # Creates a column graph with both actual and expected cumulative data.
  geom_line(aes(x = month, y = count, color = state), linewidth = 1) + # Creates a line graph with both actual and expected monthly recruitment data.
  geom_point(aes(y=count, colour = state), size=2) + # Adds a point to each month on the line graph (this helps with readability).
  geom_text(
    aes(label = cum_count),
    colour = "black", size = 1.8,
    vjust = -1.1, position = position_dodge(25)
    ) +
  coord_cartesian(
    xlim = NULL,
    ylim = c(.lower, .higher), # Sets the primary y axis limits.
    expand = TRUE,
    default = FALSE,
    clip = "on"
  ) +
  scale_x_date(date_labels = "%m/%Y", name = "Date") + # Sets format for dates on the x axis.
  scale_y_continuous(breaks = .int_breaks_rounded,
    # Features of the first axis
    name = "Monthly Randomisation", # Sets name of primary y axis.
    # Add a second axis and specify its features. Note that it is scaled by .coeff to fit the data modification in ggplot().
    sec.axis = sec_axis(~.*.coeff, name="Cumulative Randomisation", breaks = .int_breaks_rounded)
  ) + 
  theme_minimal() + # Sets theme for the graph.
  labs(fill = NULL, color = NULL) + # Controls settings for the legend.
  theme(
    legend.position="top", # Sets the position of the graph legend.
    axis.title.x = element_text(size = 12), # Controls settings for the x axis.
    axis.title.y = element_text(size=13), # Controls settings for the primary y axis.
    axis.title.y.right = element_text(size=13, angle = 90) # Controls settings for the secondary y axis.
  ) +
  ggtitle("Monthly Randomisation Count\nin Internet CBT") # Creates title for the graph.

```

```{r}
CTUReportTool::ct_recruit_timeplot(record_data = randomisation,
                                   date_var = rando_dt,
                                   date_grouping = "month",
                                   exp_start = "2023/07/01",
                                   exp_recruitment = c(34,34,34,42,42,42,42,42,42,42,42,36,36,42,42,42,42,42),
                                   title = "Monthly Randomisation Count\nin Internet CBT")
```

```{r}
#| label: tbl-sites_rec_4_cbt
#| tbl-cap: "Monthly change in Internet CBT recruitment by site."

.record_data <- merge(randomisation, contact_details, by = "record_id")
.record_data$rando_dt <- lubridate::floor_date(.record_data$rando_dt, unit = "months") 
.record_data$rando_dt <- format(.record_data$rando_dt, "%Y-%m")

.test <- CTUReportTool::ct_by_var(col_data = .record_data, col_var = cont_uni, row_var = rando_dt) %>%
  na.omit() %>%
  arrange((.$rando_dt))

for(i in seq(2,nrow(.test))) {
  .test[i,-1] <- .test[i-1,-1] + .test[i,-1]
}

rm(i)

knitr::kable(tail(.test, 4))
```

```{r}
#| label: tbl-bline_sites_cbt
#| tbl-cap: "Summary of Internet CBT sites open."

# The following creates a count of how many participants were recruited each month by site.
.cum_count <- na.omit(merge(select(dfs$randomisation, c("record_id", "rando_dt")),
                    select(dfs$contact_details, c("record_id", "cont_uni")), by = "record_id")) %>%
  group_by(month = lubridate::floor_date(rando_dt, 'month'), cont_uni) %>%
  summarise(count = n())

# The following take a cumulative count of sites that recruited their first participant by month.
.cum_count <- .cum_count[!duplicated(.cum_count$cont_uni), ] %>%
  group_by(month) %>%
  summarise(count = n()) %>%
  mutate(cum_count = cumsum(count)) %>% 
  ungroup

# Visualisation.
knitr::kable((select(.cum_count, c("month", "cum_count"))), col.names = c("Month", "Number of sites open") )

```

## Numbers of and reasons for ineligibility, non-approach and potential participant refusals

## Participant Demographics

```{r}
#| label: pri_out_pri_pool

.pri_out <- filter(.df_cbt, !is.na(.df_cbt$.trialno_cbt))

.phq_out_table <- data.frame(time = c("PHQ-9 (Baseline)", "PHQ-9 (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[1,2]),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "(Blocked)"))), .fu_3m_comp[1,3])
                             )

.gad_out_table <- data.frame(time = c("GAD-7 (Baseline)", "GAD-7 (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[3,2]),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "(Blocked)"))), .fu_3m_comp[3,3])
                             )

.lidas_out_table <- data.frame(time = c("LIDAS (Baseline)", "LIDAS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), nrow(filter(.pri_out, .pri_out$.exc2_cbt != "Has not reached timepoint")) + nrow(filter(.pri_out, !is.na(.pri_out$.induc2_cbt)))),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "(Blocked)"))), nrow(filter(.pri_out, .pri_out$.exc2_cbt == "Over timepoint window and blocked")))
                             )

.pri_out_table <- rbind(.phq_out_table,.gad_out_table)

```

```{r}
#| label: demo_data
#| output: false

.lid_count <- group_by(.pri_out, .lidas == 1) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.gad_count <- group_by(.pri_out, .gad7 > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.phq_count <- group_by(.pri_out, .phq9 > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.phq_count[.phq_count[1] == TRUE,][1] <- colnames(.phq_count)[1]
.gad_count[.gad_count[1] == TRUE,][1] <- colnames(.gad_count)[1]
.lid_count[.lid_count[1] == TRUE,][1] <- colnames(.lid_count)[1]

colnames(.phq_count)[1] <- "characteristic"
colnames(.gad_count)[1] <- "characteristic"
colnames(.lid_count)[1] <- "characteristic"

.demo_table <- rbind(.phq_count[.phq_count[1] != FALSE,], .gad_count[.gad_count[1] != FALSE,], .lid_count[.lid_count[1] != FALSE,])
rownames(.demo_table) = NULL

.gender <- make_choose_one_table(demographics$dem_gender)

.sex_orient <- make_choose_one_table(demographics$dem_sex_orient)

.uni_stat <- make_choose_one_table(demographics$dem_uni_status) 

.uni_choice <- make_choose_one_table(contact_details$cont_uni) 

.ethnic <- make_choose_all_table(demographics, "dem_ethnicity_")

.disability <- demographics$dem_disability_txt
.disability[is.na(.disability)] <- demographics$dem_disability[is.na(.disability)]
.disability[.disability == "No"] <- "No disability"
.disability <- make_choose_one_table(.disability) 

.diagnosis <- make_choose_all_table(demographics, "dem_diagnos___")

.dem_list <- list(.gender, .sex_orient, .uni_stat, .uni_choice, .ethnic, .disability, .diagnosis)

.col_name <- c("Response","No. of Responses","Percent (%)", "Percent not including NAs (%)")

.dem_list <- lapply (.dem_list, function(x) { colnames(x)[1:length(x)] <- .col_name[1:length(x)];x})
names(.dem_list) <- c(".gender", ".sex_orient", ".uni_stat", ".uni_choice", ".ethnic", ".disability", ".diagnosis")

```

```{r}
#| label: tbl-demo_gender
#| tbl-cap: "Summary of participants gender."

knitr::kable(.dem_list[".gender"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_sex
#| tbl-cap: "Summary of participants sexual orientation."

knitr::kable(.dem_list[".sex_orient"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_uni_choice
#| tbl-cap: "Summary of participants University of study."

knitr::kable(.dem_list[".uni_choice"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_uni_stat
#| tbl-cap: "Summary of participants University status."

knitr::kable(.dem_list[".uni_stat"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_ethnic
#| tbl-cap: "Summary of participants Ethnicity."

knitr::kable(.dem_list[".ethnic"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'")

```

```{r}
#| label: tbl-demo_disability
#| tbl-cap: "Summary of participants disability status."

knitr::kable(.dem_list[".disability"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'") %>%
  kableExtra::column_spec(1, width = "10cm")

```

```{r}
#| label: tbl-demo_diagnosis
#| tbl-cap: "Summary of participants disability status (continued)."

knitr::kable(.dem_list[".diagnosis"], align = 'lrrr', format = "html", table.attr = "style='width:30%;'") %>%
  kableExtra::column_spec(1, width = "10cm")

```

## Baseline

```{r}
#| label: bline_comp



```

```{r}
#| label: tbl-demo_pri
#| tbl-cap: "Summary of participants with specific criteria."

knitr::kable(.demo_table, col.names = c("Caseness","No. of Responses","Percent (%)"), align = 'lrr', format = "html", table.attr = "style='width:30%;'")

```

## Data completeness

### Number of overdue CRFs by CRF

```{r}
#| label: tbl-dcomp_bline
#| tbl-cap: "Summary of Baseline CRF Completeness."
knitr::kable(.base_comp, col.names = c("CRF Name", "Number Expected", "Number Overdue"), align = "lrr")

```

```{r}
#| label: tbl-dcomp_wk
#| tbl-cap: "Summary of Weekly Follow Up CRF Completeness."
knitr::kable(.wk_comp_total, col.names = c("CRF Name", "Number Expected", "Number Overdue"), align = "lrr")

```

```{r}
#| label: tbl-dcomp_3m
#| tbl-cap: "Summary of 3 Month Follow Up CRF Completeness."
knitr::kable(.fu_3m_comp, col.names = c("CRF Name", "Number Expected", "Number Overdue"), align = "lrr")

```

### Primary Outcome Characteristics

```{r}
#| label: tbl-pri_out_pri_pool
#| tbl-cap: "Summary of Internet CBT Primary Outcome Characteristics."

knitr::kable(.pri_out_table)

```

### Secondary Outcome Characteristics

```{r}
#| label: pri_out_sec_pool

.brood_out_table <- data.frame(time = c("Brood (Baseline)", "Brood (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[4,2]),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "(Blocked)"))), .fu_3m_comp[4,3])
                             )

.pswq_out_table <- data.frame(time = c("PSWQ (Baseline)", "PSWQ (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[5,2]),
                             num_over = c((nrow(filter(.pri_out, .pri_out$.exc1_cbt == "(Blocked)"))), .fu_3m_comp[5,3])
                             )

.sec_imp_out_table <- rbind(.brood_out_table,.pswq_out_table)

.wemwbs_base <- wemwbs %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(wemwbs_complete == "Incomplete") %>%
  select(record_id, wemwbs_complete)

.wsas_base <- wsas %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(wsas_complete == "Incomplete") %>%
  select(record_id, wsas_complete)

.use_base <- use_of_services_treatment_receivedincorporating_nh %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(use_of_services_treatment_receivedincorporating_nh_complete == "Incomplete") %>%
  select(record_id, use_of_services_treatment_receivedincorporating_nh_complete)

.res_base <- brief_resilience_scale %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(brief_resilience_scale_complete == "Incomplete") %>%
  select(record_id, brief_resilience_scale_complete)

.stress_base <- perceived_stress_scale %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(perceived_stress_scale_complete == "Incomplete") %>%
  select(record_id, perceived_stress_scale_complete)

.acad_base <- academic_grades_selfreport %>%
  filter(redcap_event_name == "Baseline") %>%
  filter(academic_grades_selfreport_complete == "Incomplete") %>%
  select(record_id, academic_grades_selfreport_complete)

colnames(.pri_out)[13] <- "record_id"

.pri_out_2 <- merge(.pri_out, .wemwbs_base, by = "record_id", all = TRUE) %>%
  merge(.wsas_base, by = "record_id", all = TRUE) %>%
  merge(.use_base, by = "record_id", all = TRUE) %>%
  merge(.res_base, by = "record_id", all = TRUE) %>%
  merge(.stress_base, by = "record_id", all = TRUE) %>%
  merge(.acad_base, by = "record_id", all = TRUE)

.wemwbs_no <- .pri_out_2 %>%
  filter(wemwbs_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.wsas_no <- .pri_out_2 %>%
  filter(wsas_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.use_no <- .pri_out_2 %>%
  filter(use_of_services_treatment_receivedincorporating_nh_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.res_no <- .pri_out_2 %>%
  filter(brief_resilience_scale_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.stress_no <- .pri_out_2 %>%
  filter(perceived_stress_scale_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.acad_no <- .pri_out_2 %>%
  filter(academic_grades_selfreport_complete == "Incomplete") %>%
  filter(.exc1_cbt == "(Blocked)") %>%
  nrow()

.wemwbs_out_table <- data.frame(time = c("WEMWBS (Baseline)", "WEMWBS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[6,2]),
                             num_over = c(.wemwbs_no, .fu_3m_comp[6,3])
                             )

.wsas_out_table <- data.frame(time = c("WSAS (Baseline)", "WSAS (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[10,2]),
                             num_over = c(.wsas_no, .fu_3m_comp[10,3])
                             )

.use_out_table <- data.frame(time = c("Use of Services (Baseline)", "Use of Services (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[13,2]),
                             num_over = c(.use_no, .fu_3m_comp[13,3])
                             )

.res_out_table <- data.frame(time = c("Resiliance (Baseline)", "Resiliance (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[11,2]),
                             num_over = c(.res_no, .fu_3m_comp[11,3])
                             )

.stress_out_table <- data.frame(time = c("Stress (Baseline)", "Stress (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[7,2]),
                             num_over = c(.stress_no, .fu_3m_comp[7,3])
                             )
.acad_out_table <- data.frame(time = c("Academic Outcomes (Baseline)", "Academic Outcomes (3 Month FU)"),
                             num_exp = c(nrow(.pri_out), .fu_3m_comp[12,2]),
                             num_over = c(.acad_no, .fu_3m_comp[12,3])
                             )

.sec_out_table <- rbind(.sec_imp_out_table, .wemwbs_out_table, .wsas_out_table, .use_out_table, .res_out_table, .stress_out_table, .acad_out_table)


```

```{r}
#| label: tbl-pri_out_sec_pool
#| tbl-cap: "Summary of Internet CBT Secondary Outcome Characteristics."

knitr::kable(.sec_out_table, col.names = c("Outcome (timepoint)", "Number expected", "Number overdue"))
# outcome (timepoint), number expected, number overdue
```

## Follow Up

### Withdrawals

```{r}
#| label: with_checker

# Prints the number of withdrawals.
.any_with <- ifelse(exists('withdrawal') == TRUE, sprintf("There have been %s withdrawals during this trial", nrow(filter(withdrawal, withdrawal_complete == "Complete"))), "There have been no withdrawals in this trial")
print(.any_with)

```

```{r}
#| label: tbl-withdrawal
#| tbl-cap: "Summary of Reducing Worry withdrawals."

.with_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('withdrawal') == TRUE){.with_list <- select(filter(withdrawal, withdrawal_complete == "Complete"), "with_acu_ch_dt", "with_acu_type", "with_acu_timepoint", "with_acu_reason", "record_id")}
colnames(.with_list) <- c("Date of Status Change", "Withdrawal type", "Withdrawal timepoint", "Reason for withdrawal", "Record ID")

knitr::kable(.with_list)

```

### Follow Up Progress

```{r}
#| label: tbl-prog_stat_wk
#| tbl-cap: "Summary of Internet CBT Weekly Follow Up progress."

# Selects necessary data and creates a new variable showing how many weeks since randomisation occurred.
.rand_data <- select(filter(randomisation, redcap_event_name == "Baseline"), c("record_id", "randomisation_complete", "rando_dt"))
.rand_data <- merge(mutate(.rand_data, 
                           weeks_since = ceiling(difftime(Sys.Date(), .rand_data$rando_dt,units = "weeks"))-1),
                    select(filter(contact_details, redcap_event_name == "Baseline"),c("record_id","cont_method")),
                    by = "record_id")

# Selects necessary data about follow up completion.  
.fu_data <- merge(select(problem_clarification_819b84, 
                         c("record_id", "redcap_event_name", "problem_clarification_819b84_complete")),
      select(filter(contact_details, redcap_event_name == "Baseline"),c("record_id","cont_method")),
      by = "record_id")
.fu_data <- na.omit(.fu_data) # Removes NAs from data.

.df_data <- data.frame() # Creates an empty dataframe to store weekly data in.
.week_no <- 0 # A variable to loop over for each week of data.

while (.week_no < 8) { # A loop to gather data for each follow up week.
  .week_no <- .week_no + 1 # Sets follow up number for each loop.
  
  .expected_data <- filter(.rand_data, weeks_since >= .week_no) %>% # Filters data to only include participants who are at this follow up week or later.
    filter(!grepl("Incomplete", randomisation_complete, ignore.case = TRUE)) # Removes participants who did not complete baseline.
  
  .completed_data <- filter(.fu_data, grepl(paste("Week", .week_no), redcap_event_name, ignore.case = TRUE)) %>% # Filters data to only include participants who are at this follow up week or later.
    filter(!grepl("Incomplete", problem_clarification_819b84_complete, ignore.case = TRUE)) # Removes participants who did not complete the follow up for this week.
  
  .expected <- nrow(.expected_data) # Counts number of participants expected to have completed this follow up week.
  .completed <- nrow(.completed_data) # Counts number of participants who have completed this follow up week.
  
  .exp_ph <- .expected_data %>%
    filter(!grepl("Email", cont_method, ignore.case = TRUE)) %>% # Filters data to only include participants who selected "text" as their preferred method of communication.
    nrow() # Counts number of participants.
  .exp_em <- .expected - .exp_ph # Calculates number of participants.
  
  .com_ph <- .completed_data %>%
    filter(!grepl("Email", cont_method, ignore.case = TRUE)) %>% # Filters data to only include participants who selected "text" as their preferred method of communication.
    nrow() # Counts number of participants.
  .com_em <- .completed - .com_ph # Calculates number of participants.
  
  .df_data <- rbind(.df_data, c(.week_no, .expected, .completed,.exp_ph, .com_ph, .exp_em, .com_em)) # Adds week data to the dataframe.
}

.df_data <- rename(.df_data, week = names(.df_data)[1], expected = names(.df_data)[2], completed = names(.df_data)[3], expected_t = names(.df_data)[4], completed_t = names(.df_data)[5], expected_e = names(.df_data)[6], completed_e = names(.df_data)[7])

# Visualisation. 
knitr::kable(.df_data, col.names = c("Week","Expected Completion","Actual Completion", "Expected (text)", "Completed (text)", "Expected (email)", "Completed (email)"))

```

```{r}
#| label: tbl-prog_caseness_3m
#| tbl-cap: "Summary of Internet CBT 3 Month Participant Caseness."

.gad_3m_count <- group_by(gad7_fu, gad_flo_total > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

.phq_3m_count <- group_by(phq9_fu, phq_flo_total > 9) %>%
  summarise(count = n()) %>%
  mutate(percent = (count/sum(count)) * 100) %>%
  as.data.frame()

if(nrow(.phq_3m_count[.phq_3m_count[1] == TRUE,]) == 1) {
  .phq_3m_count[.phq_3m_count[1] == TRUE,][1] <- colnames(.phq_3m_count)[1]
}

if(nrow(.gad_3m_count[.gad_3m_count[1] == TRUE,]) == 1) {
  .gad_3m_count[.gad_3m_count[1] == TRUE,][1] <- colnames(.gad_3m_count)[1]
}



#colnames(.phq_3m_count)[1] <- "characteristic"
#colnames(.gad_3m_count)[1] <- "characteristic"

.demo_3m_table <- rbind(.phq_3m_count[.phq_3m_count[1] != FALSE,], .gad_3m_count[.gad_3m_count[1] != FALSE,])
rownames(.demo_3m_table) = NULL

#knitr::kable(.demo_3m_table, col.names = c("Caseness","No. of Responses","Percent (%)"), align = 'lrr', format = "html", table.attr = "style='width:30%;'")
knitr::kable(.demo_3m_table, col.names = c("Caseness","No. of Responses","Percent (%)"), align = 'lrr')
```

```{r}
#| label: tbl-prog_stat_3m
#| tbl-cap: "Summary of Internet CBT 3 Month Follow Up progress."

.fu_3m_prog <- data.frame(num_exp = .fu_3m_comp[1,2], 
                             num_comp = nrow(filter(.fu_3m_data, !is.na(.fu_3m_comp))))

knitr::kable(.fu_3m_prog, col.names = c("Number Expected", "Number Completed"))
```


## Safety

### AEs

```{r}
#| label: ae_checker

# Prints the number of AEs.
.any_ae <- ifelse(exists('ae') == TRUE, sprintf("There have been %s AEs during this trial", nrow(filter(ae, ae_complete == "Complete"))), "There have been no AEs in this trial")
print(.any_ae)

```

```{r}
#| label: tbl-ae
#| tbl-cap: "Summary of Adverse Events."

.ae_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('ae') == TRUE){.ae_list <- select(filter(ae, ae_complete == "Complete"), "ae_acu_number", "ae_acu_event_name", "ae_acu_start_dt", "ae_acu_relation" , "ae_acu_ppt_id")}
colnames(.ae_list) <- c("AE Number", "AE Event Name", "AE Start Date", "Relationship to Trial" , "Record ID")

knitr::kable(.ae_list)

```

### SAEs

```{r}
#| label: sae_checker

# Prints the number of SAEs.
.any_sae <- ifelse(exists('sae') == TRUE, sprintf("There have been %s SAEs during this trial", nrow(filter(sae, sae_complete == "Complete"))), "There have been no SAEs in this trial")
print(.any_sae)

```

```{r}
#| label: tbl-sae
#| tbl-cap: "Summary of Severe Adverse Events."

.sae_list <- as.data.frame(matrix(ncol = 5, nrow = 0))
if(exists('sae') == TRUE){.sae_list <- select(filter(sae, sae_complete == "Complete"), "sae_acu_number", "sae_acu_event_name", "sae_acu_start_dt", "sae_acu_relation" , "sae_acu_ppt_id")}
colnames(.sae_list) <- c("SAE Number", "SAE Event Name", "SAE Start Date", "Relationship to Trial" , "Record ID")

knitr::kable(.sae_list)

```
